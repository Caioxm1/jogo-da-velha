<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo da Velha - Batalha na Arena</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --cor-fundo: #1a2a33;
            --cor-tabuleiro: #1f3641;
            --cor-celula: #a8bfc9;
            --cor-celula-hover: #dbe8ef;
            --cor-x: #31c3bd;
            --cor-o: #f2b137;
            --cor-texto: #ffffff;
            --sombra: 0 8px 16px rgba(0, 0, 0, 0.25);
            --vida-cor: #2ecc71;
            --vida-fundo: #4a5a63;
            --dano-cor: #e74c3c;
            --escudo-cor: #3498db;
            --espelho-cor: #9b59b6;
            --interdicao-cor: #e74c3c;
            --amaldicoado-cor: #8e44ad;
            --font-principal: 'Poppins', sans-serif;
            --font-titulo: 'Bangers', cursive;
        }

        *, *::after, *::before {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Evita rolagem na página principal */
        }

        body {
            font-family: var(--font-principal);
            color: var(--cor-texto);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px; /* Reduz o padding para aproveitar a tela */
            background: linear-gradient(-45deg, #10212b, #1a2a33, #1f3641, #31c3bd);
            background-size: 400% 400%;
            animation: animated-background 20s ease infinite;
        }

        #game-container {
            text-align: center;
            width: 100%;
            max-width: 450px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        .screen {
            width: 100%;
            height: 100%; /* Faz a tela ocupar todo o contêiner */
            position: absolute;
            top: 0;
            left: 0;
            background-color: transparent;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Centraliza o conteúdo da tela */
        }

        .screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--cor-fundo);
            z-index: -1;
            border-radius: 20px;
            opacity: 0.9;
        }

        .screen.active {
            visibility: visible;
            opacity: 1;
            z-index: 10;
        }
        
        /* Ajustes na tela do jogo para melhor distribuição vertical */
        #game-screen {
            justify-content: space-around; /* Distribui os elementos */
        }

        h1, h2, h3 {
            font-family: var(--font-titulo);
            font-weight: 400;
            letter-spacing: 1px;
        }
        
        h1 {
            font-size: clamp(2.5rem, 10vw, 3.5rem); /* Aumenta a responsividade da fonte */
            margin-bottom: 1rem;
            color: var(--cor-celula);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        h2 {
            font-size: clamp(1.2rem, 6vw, 1.5rem);
            margin-bottom: 1rem;
            color: var(--cor-celula-hover);
        }
        
        h3 {
            font-size: clamp(1rem, 5vw, 1.2rem);
            margin-bottom: 0.5rem;
            color: var(--cor-o);
        }

        .menu-button {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding: clamp(0.8rem, 4vw, 1.2rem); /* Padding adaptável */
            font-size: clamp(1rem, 4.5vw, 1.2rem);
            font-weight: 700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            color: var(--cor-tabuleiro);
            background-color: var(--cor-celula);
            box-shadow: inset 0 -4px 0 #899ba5;
            transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.2s;
            margin-top: 1rem;
        }

        .menu-button:disabled {
            background-color: var(--vida-fundo);
            box-shadow: inset 0 -4px 0 #3a4952;
            cursor: not-allowed;
            color: #7b8c96;
        }

        .menu-button:active:not(:disabled) {
            transform: translateY(2px) scale(0.98);
            box-shadow: inset 0 -2px 0 #899ba5;
        }

        .menu-button.secondary {
            background-color: var(--cor-tabuleiro);
            color: var(--cor-celula);
            box-shadow: inset 0 -4px 0 #10212b;
        }

        .menu-button.tatico {
            background-color: var(--cor-o);
            color: var(--cor-fundo);
            box-shadow: inset 0 -4px 0 #b48328;
        }

        #save-profile-button {
            animation: pulse-active-player 2.5s infinite;
        }

        .menu-button.animated-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -150%;
            width: 75%;
            height: 100%;
            background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.4) 50%, rgba(255, 255, 255, 0) 100%);
            transform: skewX(-25deg);
            animation: shine-sweep 4s infinite;
            animation-delay: var(--delay, 0s);
        }

        /* --- ARSENAL SCREEN STYLES --- */
        #arsenal-screen .profile-container {
            background-color: var(--cor-tabuleiro);
            padding: 1.5rem;
            border-radius: 15px;
            margin-bottom: 1.5rem;
            box-shadow: var(--sombra);
        }
        
        .arsenal-layout {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .skill-selection-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        @media (min-width: 768px) {
            #game-container { max-width: 800px; }
            .arsenal-layout { flex-direction: row; }
            .profile-container { flex: 1; }
            .skill-selection-container { flex: 2; }
        }

        #skill-deck-container, #player-kit-container {
            background-color: var(--cor-tabuleiro);
            padding: 1rem;
            border-radius: 15px;
        }

        .skill-deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); /* Reduz o tamanho mínimo para caber mais em telas estreitas */
            gap: 1.2rem; /* Reduz o espaçamento */
            align-content: start; /* Alinha as linhas no topo, evitando que se estiquem */
        }

        .player-kit-slots {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            background-color: var(--cor-fundo);
            border-radius: 10px;
        }
        
        .kit-slot {
            width: 70px;
            height: 95px;
            border: 2px dashed var(--cor-celula);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: var(--cor-celula);
        }
        
        .skill-card {
            background-color: var(--cor-fundo);
            border: 2px solid var(--cor-celula);
            border-radius: 10px;
            padding: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1.3;
            min-height: 95px;
        }
        
        .skill-card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px var(--cor-celula-hover);
        }

        .skill-card.selected {
            border-color: var(--cor-o);
            box-shadow: 0 0 15px var(--cor-o);
            background-color: #2f4858;
        }
        
        .skill-card .skill-icon {
            font-size: 2rem;
            line-height: 1;
        }

        .skill-card .skill-name {
            font-size: 0.7rem;
            font-weight: 600;
            margin-top: 0.5rem;
            text-align: center;
        }
        
        .player-input-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            width: 100%;
            margin-top: 1rem;
        }

        .char-preview {
            width: 70px; height: 70px;
            cursor: pointer;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            transition: transform 0.2s, filter 0.2s;
            flex-shrink: 0;
            border: 2px dashed var(--cor-celula);
            border-radius: 10px;
        }
        .char-preview:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 0 8px var(--color, var(--cor-celula)));
        }

        #char-preview-x { --color: var(--cor-x); }
        #char-preview-o { --color: var(--cor-o); }

        .player-name-input {
            flex-grow: 1;
            padding: 0.8rem;
            border-radius: 8px;
            border: 2px solid var(--cor-celula);
            background-color: var(--cor-fundo);
            color: white;
            font-size: 1rem;
            font-family: var(--font-principal);
            width: 100%;
        }
        .player-name-input:focus {
            outline: none;
            border-color: var(--color);
            --color: var(--cor-x);
        }
        
        /* --- Health, Skills, Board etc --- */
        .health-bars {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .health-container {
            width: 48%; padding: 5px;
            border-radius: 12px;
            transition: box-shadow 0.3s ease, transform 0.3s ease;
        }

        .health-container.active {
            animation: pulse-active-player-enhanced 2s infinite ease-in-out;
        }

        .player-label {
            font-weight: 600;
            font-size: clamp(0.8rem, 3.5vw, 1rem); /* Fonte adaptável */
            margin-bottom: 0.5rem;
            white-space: nowrap; /* Evita que o nome quebre a linha */
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-label.player-x { color: var(--cor-x); }
        .player-label.player-o { color: var(--cor-o); }

        .health-bar-background {
            width: 100%; height: 18px;
            background-color: var(--vida-fundo);
            border-radius: 10px; overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.3s;
        }

        .health-bar-background.damage {
            animation: health-bar-damage 0.5s ease-in-out;
        }

        .health-bar-foreground {
            height: 100%; width: 100%;
            background-color: var(--vida-cor);
            border-radius: 10px;
            transition: width 0.5s ease-in-out;
        }

        .skills-container {
            display: none;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding: 0 5%; /* Adiciona padding lateral */
        }
        .skills-container.show {
            display: flex;
        }
        .skill-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .skill-button {
            background: var(--cor-tabuleiro);
            border: 2px solid var(--cor-celula);
            color: white;
            font-size: 1.5rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }
        .skill-button:hover:not(:disabled) {
            transform: scale(1.1);
            background-color: var(--cor-celula-hover);
            color: var(--cor-fundo);
        }
        .skill-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            background-color: var(--vida-fundo);
        }

        .battle-arena {
            height: 80px; background-color: var(--cor-tabuleiro);
            margin-bottom: 1rem; border-radius: 10px;
            display: flex; justify-content: space-between;
            align-items: center; padding: 0 20px;
            position: relative; overflow: hidden;
        }

        .character {
            width: 60px; height: 60px;
            position: relative;
            transition: transform 0.3s ease, background-color 0.3s, box-shadow 0.3s, opacity 0.4s, filter 0.4s;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            display: flex; justify-content: center;
            align-items: center; font-size: 30px;
            line-height: 1;
        }

        .character.turn-active::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 130%;
            height: 130%;
            background: radial-gradient(circle, var(--player-color) 20%, transparent 65%);
            border-radius: 50%;
            z-index: -1;
            animation: aura-glow 2.5s infinite ease-in-out;
        }

        .character.shielded {
            animation: pulse-shield 1.5s infinite;
        }
        
        .character.damage-boost {
            animation: pulse-damage-boost 1.5s infinite;
        }

        .character.mirror-active {
            animation: pulse-mirror 1.5s infinite;
        }

        .character.attack { animation: energetic-attack 0.6s ease-in-out; }
        .character.hit { animation: heavy-hit 0.6s ease-in-out; }
        .character.victory { animation: victory-pose 2s forwards; }
        .character.defeat { animation: defeat-pose 1.5s forwards; }

        .board {
            display: grid; 
            grid-template-columns: repeat(3, 1fr);
            gap: 10px; /* Reduz o gap para telas menores */
            width: 100%; 
            max-width: 400px; /* Limita o tamanho máximo para não ficar enorme */
            aspect-ratio: 1 / 1;
            margin: 0 auto; 
            background-color: var(--cor-tabuleiro);
            border-radius: 15px; 
            padding: 10px; 
            box-shadow: var(--sombra);
            pointer-events: auto;
            position: relative; 
        }

        .board.locked {
            pointer-events: none;
        }

        .board.targeting .cell {
            cursor: not-allowed;
            opacity: 0.6;
            pointer-events: none;
        }
        
        .board.targeting .cell.targetable {
            cursor: crosshair;
            animation: pulse-target 1s infinite;
            opacity: 1;
            pointer-events: auto;
        }
        
        .board.targeting-sacrifice.targeting .cell.x,
        .board.targeting-sacrifice.targeting .cell.o {
             cursor: not-allowed; opacity: 0.6; pointer-events: none;
        }

        .board.targeting-sacrifice.targeting.is-x-turn .cell.x,
        .board.targeting-sacrifice.targeting.is-o-turn .cell.o {
            cursor: crosshair !important;
            animation: pulse-target 1s infinite !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        .board.targeting-swap.targeting .cell:not(.x):not(.o),
        .board.targeting-shove.targeting .cell.x,
        .board.targeting-shove.targeting .cell.o {
            cursor: not-allowed; opacity: 0.6; pointer-events: none;
        }
        .board.targeting-swap.targeting .cell.x,
        .board.targeting-swap.targeting .cell.o,
        .board.targeting-shove.targeting .cell.targetable,
        .board.targeting-shove.targeting .cell.shove-origin {
             cursor: crosshair;
             opacity: 1;
             pointer-events: auto;
        }
        
        .board.targeting .cell.swap-first-pick,
        .board.targeting .cell.shove-origin {
            animation: pulse-shield 1s infinite;
            opacity: 1;
        }
        
        .board.targeting-shove.targeting .cell:not(.targetable):not(.shove-origin) {
            cursor: not-allowed; opacity: 0.6; pointer-events: none;
        }

        .board.dimmed-board::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 15px; 
            z-index: 9; 
            opacity: 0; 
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
        }
        
        .board.dimmed-board.dimmed-board::after {
            opacity: 1;
            visibility: visible;
        }

        .cell {
            background-color: var(--cor-celula);
            border-radius: 10px; cursor: pointer;
            position: relative; box-shadow: inset 0 -4px 0 #899ba5;
            transition: transform 0.2s, background-color 0.2s, opacity 0.3s, box-shadow 0.3s;
            overflow: hidden; 
        }

        .cell:not(.x):not(.o):not(:disabled):hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4), inset 0 -4px 0 #899ba5;
        }

        .cell.oldest-piece {
            animation: fade-out-pulse 2s infinite ease-in-out;
        }

        .cell.interdicted {
            cursor: not-allowed !important;
            background-color: #556672 !important;
            animation: shake 0.5s;
        }

        .cell.interdicted::after {
            content: '🚫';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: var(--interdicao-cor);
            opacity: 0.8;
        }

        .cell.cursed {
            box-shadow: 0 0 10px 5px var(--amaldicoado-cor);
            animation: pulse-cursed 1s infinite;
        }

        .cell.mined::after {
            content: '💣'; 
            position: absolute;
            font-size: 1rem;
            top: 5px;
            right: 5px;
            opacity: 0.8;
        }
        
        .cell.portal {
            box-shadow: 0 0 15px 5px var(--espelho-cor);
            animation: pulse-portal 1.5s infinite;
        }
        
        .cell.x, .cell.o { cursor: not-allowed; }

        @keyframes place-mark-pop-in {
            0% { transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(0.5); opacity: 0; }
            80% { transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(1); opacity: 1; }
        }

        .cell.x::before, .cell.x::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 12%; /* Deixa o X um pouco mais grosso */
            background-color: var(--cor-x);
            border-radius: 5px;
            transform-origin: center;
            animation: place-mark-pop-in 0.3s ease-out forwards;
            pointer-events: none;
        }
        .cell.x::before {
            --rotation: 45deg;
            transform: translate(-50%, -50%) rotate(var(--rotation));
        }
        .cell.x::after {
            --rotation: -45deg;
            transform: translate(-50%, -50%) rotate(var(--rotation));
        }

        .cell.o::before {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 65%; height: 65%; background-color: transparent;
            border: 10px solid var(--cor-o); /* Borda mais fina para telas pequenas */
            border-radius: 50%;
            animation: place-mark-pop-in 0.3s ease-out forwards;
            pointer-events: none;
        }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 1rem;
        }
        .modal-overlay.show {
            display: flex;
        }

        .modal-content, .winning-message-content {
            background-color: var(--cor-tabuleiro);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: var(--sombra);
            color: white;
            text-align: center;
            width: 100%;
            max-width: 400px;
        }

        .modal-content h2 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .character-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .preset-char {
            font-size: 2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .preset-char:hover {
            transform: scale(1.2);
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .modal-upload-button {
            display: inline-block;
            font-size: 1rem;
            font-weight: 600;
            background-color: var(--cor-celula);
            color: var(--cor-tabuleiro);
            border: none;
            border-radius: 10px;
            padding: 0.8rem 1.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .modal-upload-button:hover {
            background-color: #fff;
        }

        .winning-message-content {
            font-family: var(--font-titulo);
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 400;
        }
        
        .winning-message-content button {
            font-family: var(--font-principal);
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            font-weight: 600;
            background-color: var(--cor-celula);
            color: var(--cor-tabuleiro);
            border: none;
            border-radius: 10px;
            padding: 1rem 2rem;
            cursor: pointer;
            margin-top: 2rem;
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .winning-message-content button:hover {
            transform: scale(1.05);
            background-color: #fff;
        }

        .turn-announcement-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 85%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
        }
        
        .turn-announcement-container.show {
            animation: fade-in-out 2s ease-in-out forwards;
        }
        
        .turn-announcement-text {
            font-family: var(--font-titulo);
            font-size: clamp(1.8rem, 8vw, 2.5rem);
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            padding: 1rem 2rem;
            background-color: rgba(26, 42, 51, 0.7);
            border-radius: 15px;
            backdrop-filter: blur(4px);
        }

        /* --- ESTILOS DO HISTÓRICO DE AÇÕES --- */
        #history-toggle-button {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 20; /* Fica acima do painel e da tela de jogo */
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            border-radius: 50%;
            background-color: var(--cor-tabuleiro);
            color: var(--cor-celula);
            border: 2px solid var(--cor-celula);
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            display: none; /* Começa escondido, aparece só na tela de jogo */
        }

        #history-toggle-button.visible {
            display: block;
        }

        #history-toggle-button:hover {
            transform: scale(1.1);
            background-color: var(--cor-celula-hover);
            color: var(--cor-fundo);
        }

        #history-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 250px; /* Largura do painel */
            height: 100%;
            background-color: rgba(31, 54, 65, 0.85); /* Fundo com 85% de opacidade */
            backdrop-filter: blur(8px); /* Efeito de vidro fosco */
            border-left: 2px solid var(--cor-o);
            box-shadow: -5px 0 25px rgba(0,0,0,0.5);
            z-index: 19;
            padding: 1rem;
            padding-top: 70px; /* Espaço para o botão não sobrepor o texto */
            transform: translateX(100%); /* Começa escondido fora da tela à direita */
            transition: transform 0.4s ease-in-out;
            pointer-events: none; /* Não interage enquanto escondido */
        }

        #history-panel.show {
            transform: translateX(0); /* Fica visível na tela */
            pointer-events: auto; /* Pode ser interagido */
        }

        #history-log-content {
            height: 100%;
            overflow-y: auto; /* Adiciona scroll se o conteúdo for maior que o painel */
            display: flex;
            flex-direction: column-reverse; /* Mensagens novas aparecem em cima */
        }

        .log-entry {
            padding: 0.5rem;
            border-bottom: 1px solid var(--cor-fundo);
            font-size: 0.9rem;
            animation: fade-in-entry 0.5s ease;
            text-align: left;
            word-wrap: break-word;
        }

        /* Cores para os jogadores no log */
        .log-entry.player-x-log { color: var(--cor-x); }
        .log-entry.player-o-log { color: var(--cor-o); }
        .log-entry.system-log { color: var(--cor-celula-hover); font-style: italic; }

        @keyframes fade-in-entry {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Estilizando a barra de rolagem (opcional, mas elegante) */
        #history-log-content::-webkit-scrollbar { width: 5px; }
        #history-log-content::-webkit-scrollbar-track { background: transparent; }
        #history-log-content::-webkit-scrollbar-thumb { background-color: var(--cor-o); border-radius: 10px; }
        
        /* ===== INÍCIO DO AJUSTE DA TELA DE CAMPANHA (VERSÃO CORRIGIDA) ===== */

        /* Garante que o layout da tela da campanha distribua o espaço corretamente */
        #campaign-map-screen {
            justify-content: space-between; 
            gap: 1rem;
        }

        /* Faz o título e o botão de voltar não encolherem */
        #campaign-map-screen > h1,
        #campaign-map-screen > #back-to-menu-from-campaign {
            flex-shrink: 0;
        }

        /* Transforma a grade de níveis em uma área rolável */
        #campaign-level-grid {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden; /* PROÍBE o scroll horizontal indesejado */
            padding: 0.5rem 1rem;
            min-height: 0; /* Correção crítica para o scroll em layout flex */
        }

        /* Estiliza a barra de rolagem para combinar com o jogo */
        #campaign-level-grid::-webkit-scrollbar {
            width: 8px;
        }

        #campaign-level-grid::-webkit-scrollbar-track {
            background: var(--cor-fundo); 
            border-radius: 10px;
        }

        #campaign-level-grid::-webkit-scrollbar-thumb {
            background-color: var(--cor-o);
            border-radius: 10px;
            border: 2px solid var(--cor-fundo);
        }

        #campaign-level-grid::-webkit-scrollbar-thumb:hover {
            background-color: #ffca6e; /* Uma versão mais clara do laranja para o hover */
        }

        /* ===== FIM DO AJUSTE ===== */
        
        #campaign-level-grid .menu-button {
            width: auto;
            min-width: 100px;
            aspect-ratio: 1 / 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            line-height: 1.2;
        }
        #campaign-level-grid .menu-button[disabled] {
            opacity: 0.7;
        }
        #campaign-level-grid .mission-complete {
            background-color: var(--cor-x);
            box-shadow: inset 0 -4px 0 #208985;
            color: var(--cor-fundo);
        }

        @keyframes shine-sweep {
            100% { left: 150%; }
        }

        @keyframes fade-out-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes pulse-active-player-enhanced {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255,255,255,0.4);
            }
            50% {
                transform: scale(1.03);
                box-shadow: 0 0 12px 6px rgba(255,255,255,0.3);
            }
        }

        @keyframes aura-glow {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.5;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 0.8;
            }
        }

        @keyframes energetic-attack {
            0% { transform: translate(0) scale(1); filter: none; }
            40% {
                transform: translate(var(--translate-x)) scale(1.3) rotate(-5deg);
                filter: drop-shadow(0 0 15px #3498db);
            }
            60% { transform: translate(calc(var(--translate-x) * 0.8)) scale(1.1) rotate(5deg); filter: none; }
            100% { transform: translate(0) scale(1); filter: none; }
        }

        @keyframes heavy-hit {
            0% { transform: translate(0); filter: none; }
            20% {
                transform: translate(var(--translate-x)) scale(0.9);
                filter: brightness(1.5) drop-shadow(0 0 15px #e74c3c);
            }
            40% { transform: translate(calc(var(--translate-x) * -0.5)) scale(1.05); filter: none; }
            60%, 80% { transform: translate(0) rotate(-3deg); }
            70%, 90% { transform: translate(0) rotate(3deg); }
            100% { transform: translate(0) rotate(0); }
        }

        @keyframes health-bar-damage {
            from, to { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); background-color: var(--dano-cor); }
            20%, 40%, 60%, 80% { transform: translateX(4px); background-color: var(--dano-cor); }
        }

        @keyframes victory-pose {
            0% { transform: scale(1) translateY(0); filter: none; }
            50% { transform: scale(1.2) translateY(-20px); filter: drop-shadow(0 0 15px var(--winner-color)); }
            100% { transform: scale(1.2) translateY(-20px); filter: drop-shadow(0 0 15px var(--winner-color)); }
        }

        @keyframes defeat-pose {
            from { transform: rotate(0); opacity: 1; filter: none; }
            to { transform: translateY(40px) rotate(-15deg); opacity: 0.4; filter: grayscale(100%); }
        }

        @keyframes pulse-target {
            0% { background-color: #ff4757; }
            50% { background-color: var(--cor-celula); }
            100% { background-color: #ff4757; }
        }
        
        @keyframes pulse-shield {
            0% { box-shadow: 0 0 10px 3px var(--escudo-cor); }
            50% { box-shadow: 0 0 25px 8px var(--escudo-cor); }
            100% { box-shadow: 0 0 10px 3px var(--escudo-cor); }
        }
        
        @keyframes pulse-damage-boost {
            0% { box-shadow: 0 0 10px 3px var(--dano-cor); filter: saturate(1.2); }
            50% { box-shadow: 0 0 25px 8px var(--dano-cor); filter: saturate(1.8); }
            100% { box-shadow: 0 0 10px 3px var(--dano-cor); filter: saturate(1.2); }
        }

        @keyframes pulse-mirror {
            0% { box-shadow: 0 0 10px 3px var(--espelho-cor); }
            50% { box-shadow: 0 0 25px 8px var(--espelho-cor); }
            100% { box-shadow: 0 0 10px 3px var(--espelho-cor); }
        }

        @keyframes pulse-cursed {
            0% { box-shadow: 0 0 10px 3px var(--amaldicoado-cor); }
            50% { box-shadow: 0 0 25px 8px var(--amaldicoado-cor); }
            100% { box-shadow: 0 0 10px 3px var(--amaldicoado-cor); }
        }
        
        @keyframes pulse-portal {
            0% { box-shadow: 0 0 10px 3px var(--espelho-cor); }
            50% { box-shadow: 0 0 25px 8px var(--espelho-cor); }
            100% { box-shadow: 0 0 10px 3px var(--espelho-cor); }
        }
        
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        @keyframes pulse-active-player {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        @keyframes animated-background {
            0%{background-position:0% 50%}
            50%{background-position:100% 50%}
            100%{background-position:0% 50%}
        }

        .screen.slide-in-from-right { animation: slide-in-from-right 0.4s ease-out forwards; }
        @keyframes slide-in-from-right {
            from { transform: translateX(100%); opacity: 0; visibility: visible; }
            to { transform: translateX(0); opacity: 1; visibility: visible; }
        }

        .screen.slide-out-to-left { z-index: 1; animation: slide-out-to-left 0.4s ease-in forwards; }
        @keyframes slide-out-to-left {
            from { transform: translateX(0); opacity: 1; visibility: visible; }
            to { transform: translateX(-100%); opacity: 0; visibility: hidden; }
        }

        .screen.slide-in-from-left { animation: slide-in-from-left 0.4s ease-out forwards; }
        @keyframes slide-in-from-left {
            from { transform: translateX(-100%); opacity: 0; visibility: visible; }
            to { transform: translateX(0); opacity: 1; visibility: visible; }
        }

        .screen.slide-out-to-right { z-index: 1; animation: slide-out-to-right 0.4s ease-in forwards; }
        @keyframes slide-out-to-right {
            from { transform: translateX(0); opacity: 1; visibility: visible; }
            to { transform: translateX(100%); opacity: 0; visibility: hidden; }
        }
        
        @keyframes fade-in-out {
            0% { opacity: 0; transform: scale(0.7); visibility: visible; }
            20% { opacity: 1; transform: scale(1); }
            80% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.1); visibility: hidden; }
        }

        @keyframes particle-burst {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
                box-shadow: 0 0 15px 8px var(--particle-color);
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
                box-shadow: 0 0 0 0 rgba(0,0,0,0);
            }
        }

        .particle-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle at center, var(--particle-color) 0%, rgba(255,255,255,0) 70%);
            opacity: 0;
            animation: particle-burst 0.8s ease-out forwards;
            z-index: 5;
            pointer-events: none;
        }

        #winning-laser-line {
            position: absolute;
            background-color: var(--laser-color, var(--interdicao-cor));
            box-shadow: 0 0 10px 5px var(--laser-color, var(--interdicao-cor)), 0 0 20px 10px rgba(255, 0, 0, 0.5);
            border-radius: 5px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            transform-origin: center center;
        }

        @keyframes draw-laser-horizontal {
            0% { transform: scaleX(0); opacity: 0; }
            100% { transform: scaleX(1); opacity: 1; }
        }
        @keyframes draw-laser-vertical {
            0% { transform: scaleY(0); opacity: 0; }
            100% { transform: scaleY(1); opacity: 1; }
        }
        @keyframes draw-laser-diagonal-1 {
            0% { transform: scale(0) rotate(45deg); opacity: 0; }
            100% { transform: scale(1) rotate(45deg); opacity: 1; }
        }
        @keyframes draw-laser-diagonal-2 {
            0% { transform: scale(0) rotate(-45deg); opacity: 0; }
            100% { transform: scale(1) rotate(-45deg); opacity: 1; }
        }

        .winning-laser-active {
            opacity: 1 !important;
            animation-fill-mode: forwards;
        }

        .cell.winning-cell-pulse {
            animation: winning-cell-pulse 1s infinite alternate;
        }
        @keyframes winning-cell-pulse {
            0% { transform: scale(1); box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
            100% { transform: scale(1.05); box-shadow: 0 0 15px var(--pulse-color); }
        }

        /* --- ESTILOS VISUAIS PARA NOVOS EVENTOS CAÓTICOS --- */
        .cell.black-hole {
            background-color: #101518 !important;
            cursor: not-allowed !important;
            pointer-events: none;
            animation: black-hole-spin 2s linear infinite;
        }

        .cell.black-hole::before,
        .cell.black-hole::after {
            content: '⚫'; /* Ícone de Buraco Negro */
            font-size: 3rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 1;
            animation: none; /* Remove a animação de colocar X ou O */
            background-color: transparent;
            border: none;
            height: auto;
            width: auto;
        }

        @keyframes black-hole-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .cell.foggy {
            background-color: #8b9da5;
        }

        .cell.foggy::before,
        .cell.foggy::after {
            content: '❓'; /* Ícone de Névoa */
            font-size: 3rem;
            color: var(--cor-fundo);
            opacity: 1;
            transform: translate(-50%, -50%);
            animation: none;
            background-color: transparent;
            border: none;
            height: auto;
            width: auto;
        }
        
        /* Efeito para a barra de vida durante a Inversão de Poder */
        .health-container.power-inversion-glow {
            animation: pulse-power-inversion 1.5s infinite;
        }

        @keyframes pulse-power-inversion {
            0% { box-shadow: 0 0 8px 2px var(--espelho-cor); }
            50% { box-shadow: 0 0 20px 7px var(--espelho-cor); }
            100% { box-shadow: 0 0 8px 2px var(--espelho-cor); }
        }

        /* Regras específicas para orientação retrato (celulares) */
        @media (orientation: portrait) {
            #game-container {
                justify-content: space-around; /* Distribui melhor o espaço */
            }

            #game-screen {
                 justify-content: space-around;
            }

            .board {
                gap: 10px;
                padding: 10px;
            }
        }

    </style>
</head>
<body>
    <div id="game-container">
        
        <button id="history-toggle-button">📜</button>
        <div id="history-panel">
            <h3>Histórico de Ações</h3>
            <div id="history-log-content">
            </div>
        </div>

        <div id="arsenal-screen" class="screen">
            <h1>Arsenal do Jogador</h1>
            <div class="arsenal-layout">
                <div class="profile-container">
                    <h2>Seu Perfil</h2>
                    <input type="text" id="arsenal-player-name" class="player-name-input" placeholder="Digite seu nome">
                    <div class="player-input-row">
                         <div id="arsenal-char-preview" class="char-preview" title="Clique para trocar de personagem"></div>
                    </div>
                </div>

                <div class="skill-selection-container">
                    <div id="player-kit-container">
                        <h3 id="player-kit-title">Seu Kit de Batalha (Escolha 2)</h3>
                        <div class="player-kit-slots" id="player-kit-slots">
                        </div>
                    </div>
                    <div id="skill-deck-container">
                        <h2>Habilidades Desbloqueadas</h2>
                        <div class="skill-deck-grid" id="skill-deck-grid">
                        </div>
                    </div>
                </div>
            </div>
            <button class="menu-button animated-button" id="save-arsenal-button" style="--delay: 0.2s;">Salvar e Entrar na Arena</button>
        </div>

        <div id="mode-select-menu" class="screen">
            <h1>Batalha na Arena</h1>
            <button class="menu-button animated-button" id="campaign-button">Campanha: Jornada do Guerreiro</button>
            <button class="menu-button animated-button" id="single-player-button" style="--delay: 0.2s;">Partida Rápida (vs. Máquina)</button>
            <button class="menu-button animated-button" id="local-multiplayer-button" style="--delay: 0.4s;">Multiplayer Local</button>
            <button class="menu-button tatico animated-button" id="tatico-mode-button" style="--delay: 0.6s;">Modo Tático</button>
            <button class="menu-button secondary" id="change-arsenal-button" style="margin-top: 2rem;">Mudar Arsenal</button>
        </div>

        <div id="campaign-map-screen" class="screen">
            <h1>Jornada do Guerreiro</h1>
            <div id="campaign-level-grid" class="skill-deck-grid"> 
            </div>
            <button id="back-to-menu-from-campaign" class="menu-button secondary">Voltar ao Menu</button>
        </div>

        <div id="tatico-submenu" class="screen">
            <h1>Modo Tático</h1>
            <button class="menu-button animated-button" data-submode="tatico">Batalha Tática (Habilidades)</button>
            <button class="menu-button animated-button" data-submode="caotico" style="--delay: 0.2s;">Arena Caótica (Eventos)</button>
            <button id="back-to-mode-select-3" class="menu-button secondary">Voltar</button>
        </div>

        <div id="opponent-select-menu" class="screen">
            <h1 id="opponent-select-title">Escolha o Oponente</h1>
            <button class="menu-button animated-button" id="opponent-human">Jogador (Humano)</button>
            <button class="menu-button animated-button" id="opponent-ai" style="--delay: 0.2s;">Máquina (IA)</button>
            <button id="back-to-tatico-menu" class="menu-button secondary">Voltar</button>
        </div>

        <div id="difficulty-select-menu" class="screen">
            <h1>Escolha a Dificuldade</h1>
            <button class="menu-button animated-button" data-difficulty="easy">Fácil</button>
            <button class="menu-button animated-button" data-difficulty="normal" style="--delay: 0.2s;">Normal</button>
            <button class="menu-button animated-button" data-difficulty="hard" style="--delay: 0.4s;">Difícil</button>
            <button id="back-to-mode-select-2" class="menu-button secondary">Voltar</button>
        </div>

        <div id="player-setup-menu" class="screen">
            <h1>Configurar Oponente</h1>
            <div class="player-setup player-o">
                <h2>JOGADOR O</h2>
                <div class="player-input-row">
                    <div id="char-preview-o" class="char-preview"></div>
                    <input type="text" id="player-name-o" class="player-name-input" placeholder="Digite o nome do Jogador O" value="Jogador O">
                </div>
            </div>
            <button id="start-game-button" class="menu-button">Iniciar Batalha</button>
            <button id="back-to-mode-select" class="menu-button secondary">Voltar</button>
        </div>

        <div id="game-screen" class="screen">
            <div class="health-bars">
                <div class="health-container" id="health-container-x">
                    <div class="player-label player-x" id="game-player-label-x">JOGADOR X</div>
                    <div class="health-bar-background" id="health-bg-x">
                        <div class="health-bar-foreground" id="health-bar-x"></div>
                    </div>
                </div>
                <div class="health-container" id="health-container-o">
                    <div class="player-label player-o" id="game-player-label-o">JOGADOR O</div>
                    <div class="health-bar-background" id="health-bg-o">
                        <div class="health-bar-foreground" id="health-bar-o"></div>
                    </div>
                </div>
            </div>

            <div class="skills-container" id="skills-container">
                <div class="skill-group" id="skills-x">
                </div>
                <div class="skill-group" id="skills-o">
                </div>
            </div>

            <div class="battle-arena">
                <div class="character" id="player-x-char"></div>
                <div class="character" id="player-o-char"></div>
            </div>

            <div id="game-board" class="board"></div>
            <div id="winning-laser-line"></div>

            <div id="turn-announcement" class="turn-announcement-container">
                <div id="turn-announcement-text" class="turn-announcement-text"></div>
            </div>
        </div>

        <div id="winning-message" class="modal-overlay">
            <div class="winning-message-content">
                <div data-winning-message-text></div>
                <button id="restartButton">Continuar</button>
            </div>
        </div>
        <div id="character-select-modal" class="modal-overlay">
            <div class="modal-content">
                <h2>Escolha seu Personagem</h2>
                <div id="preset-characters" class="character-grid"></div>
                <label for="modal-upload" class="modal-upload-button">Carregar sua foto</label>
                <input type="file" id="modal-upload" class="char-upload" accept="image/*" style="display: none;">
            </div>
        </div>
        <div id="notification-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 id="notification-title">Atenção</h2>
                <div id="notification-text" style="margin-bottom: 1.5rem; text-align: left;"></div>
                <button id="notification-close-button" class="menu-button">Entendi</button>
            </div>
        </div>


        <audio id="menu-music" src="https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/main/musicamenu.mp3" loop preload="auto"></audio>
        <audio id="battle-music" src="https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/main/musicabatalha.mp3" loop preload="auto"></audio>
        <audio id="attack-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/golpe.mp3" preload="auto"></audio>
        <audio id="hit-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/dano.mp3" preload="auto"></audio>
        <audio id="victory-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/vitoria.mp3" preload="auto"></audio>
        <audio id="shield-sound" src="https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/raw/main/prote%C3%A7ao.mp3" preload="auto"></audio>
        <audio id="bomb-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/explos%C3%A3o.mp3" preload="auto"></audio>
        <audio id="click-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/11L-bubble_bursting-1750158387072.mp3" preload="auto"></audio>
        <audio id="teleport-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/teleporte.mp3" preload="auto"></audio>
        <audio id="heal-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/cura.mp3" preload="auto"></audio>

        <script>
            // --- ELEMENT MAPPING ---
            const arsenalScreen = document.getElementById('arsenal-screen');
            const arsenalPlayerNameInput = document.getElementById('arsenal-player-name');
            const arsenalCharPreview = document.getElementById('arsenal-char-preview');
            const saveArsenalButton = document.getElementById('save-arsenal-button');
            const skillDeckGrid = document.getElementById('skill-deck-grid');
            const playerKitSlots = document.getElementById('player-kit-slots');
            const playerKitTitle = document.getElementById('player-kit-title');
            const changeArsenalButton = document.getElementById('change-arsenal-button');
            const modeSelectMenu = document.getElementById('mode-select-menu');
            const taticoSubmenu = document.getElementById('tatico-submenu');
            const opponentSelectMenu = document.getElementById('opponent-select-menu');
            const difficultySelectMenu = document.getElementById('difficulty-select-menu');
            const playerSetupMenu = document.getElementById('player-setup-menu');
            const gameScreen = document.getElementById('game-screen');
            const singlePlayerButton = document.getElementById('single-player-button');
            const localMultiplayerButton = document.getElementById('local-multiplayer-button');
            const taticoModeButton = document.getElementById('tatico-mode-button');
            const taticoSubmenuButtons = document.querySelectorAll('#tatico-submenu [data-submode]');
            const opponentHumanButton = document.getElementById('opponent-human');
            const opponentAiButton = document.getElementById('opponent-ai');
            const difficultyButtons = document.querySelectorAll('[data-difficulty]');
            const backToModeSelectBtn = document.getElementById('back-to-mode-select');
            const backToModeSelectBtn2 = document.getElementById('back-to-mode-select-2');
            const backToModeSelectBtn3 = document.getElementById('back-to-mode-select-3');
            const backToTaticoMenuBtn = document.getElementById('back-to-tatico-menu');
            const opponentSelectTitle = document.getElementById('opponent-select-title');
            const startGameButton = document.getElementById('start-game-button');
            const charPreviewO = document.getElementById('char-preview-o');
            const playerNameOInput = document.getElementById('player-name-o');
            const gamePlayerLabelX = document.getElementById('game-player-label-x');
            const gamePlayerLabelO = document.getElementById('game-player-label-o');
            const boardElement = document.getElementById('game-board');
            const restartButton = document.getElementById('restartButton');
            const winningMessageElement = document.getElementById('winning-message');
            const winningMessageTextElement = document.querySelector('[data-winning-message-text]');
            const healthBarX = document.getElementById('health-bar-x');
            const healthBarO = document.getElementById('health-bar-o');
            const healthBgX = document.getElementById('health-bg-x');
            const healthBgO = document.getElementById('health-bg-o');
            const healthContainerX = document.getElementById('health-container-x');
            const healthContainerO = document.getElementById('health-container-o');
            const charX = document.getElementById('player-x-char');
            const charO = document.getElementById('player-o-char');
            const modal = document.getElementById('character-select-modal');
            const presetCharsContainer = document.getElementById('preset-characters');
            const modalUploadInput = document.getElementById('modal-upload');
            const notificationModal = document.getElementById('notification-modal');
            const notificationText = document.getElementById('notification-text');
            const notificationCloseButton = document.getElementById('notification-close-button');
            const menuMusic = document.getElementById('menu-music');
            const battleMusic = document.getElementById('battle-music');
            const attackSound = document.getElementById('attack-sound');
            const hitSound = document.getElementById('hit-sound');
            const victorySound = document.getElementById('victory-sound');
            const shieldSound = document.getElementById('shield-sound');
            const bombSound = document.getElementById('bomb-sound');
            const clickSound = document.getElementById('click-sound');
            const teleportSound = document.getElementById('teleport-sound');
            const healSound = document.getElementById('heal-sound');
            const skillsMainContainer = document.getElementById('skills-container');
            const skillsXContainer = document.querySelector('#skills-x');
            const skillsOContainer = document.querySelector('#skills-o');
            const turnAnnouncementContainer = document.getElementById('turn-announcement');
            const turnAnnouncementText = document.getElementById('turn-announcement-text');
            const winningLaserLine = document.getElementById('winning-laser-line');
            const historyToggleButton = document.getElementById('history-toggle-button');
            const historyPanel = document.getElementById('history-panel');
            const historyLogContent = document.getElementById('history-log-content');
            const campaignButton = document.getElementById('campaign-button');
            const campaignMapScreen = document.getElementById('campaign-map-screen');
            const campaignLevelGrid = document.getElementById('campaign-level-grid');
            const backToMenuFromCampaignButton = document.getElementById('back-to-menu-from-campaign');
            
            // --- CONSTANTS ---
            const X_CLASS = 'x', O_CLASS = 'o';
            const WINNING_COMBINATIONS = [ [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6] ];
            const MAX_MOVES = 3, DAMAGE_PER_POINT = 20, HEALTH_DRAIN_PER_SECOND = 0.5, HEAL_AMOUNT = 25;
            const PRESET_EMOJIS = ['🦸','🥷','🤖','👹','👨‍🚀','🧛','🧙','🧟'];
            const DEFAULT_AVATAR_X = { type: 'image', value: 'https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/main/person1.png' };
            const DEFAULT_AVATAR_O = { type: 'image', value: 'https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/main/person2.png' };
            const AI_SKILL_POOL = ['bomb', 'heal', 'shield', 'sacrifice', 'mirror', 'swap', 'shove'];
            
            // SKILLS DATA STRUCTURE
            const ALL_SKILLS = {
                'heal': { id: 'heal', name: 'Cura', icon: '❤️‍🩹', description: 'Recupera 25 de vida.', type: 'active', implemented: true },
                'bomb': { id: 'bomb', name: 'Bomba', icon: '💣', description: 'Remove uma peça inimiga e interdita a célula por 1 turno.', type: 'active', implemented: true },
                'shield': { id: 'shield', name: 'Escudo', icon: '🛡️', description: 'Bloqueia o próximo ataque inimigo.', type: 'active', implemented: true },
                'vampirism': { id: 'vampirism', name: 'Vampirismo', icon: '🩸', description: 'Cura 50% do dano causado ao pontuar.', type: 'passive', implemented: true },
                'sacrifice': { id: 'sacrifice', name: 'Sacrifício', icon: '💀', description: 'Destrói uma peça sua para DOBRAR o dano do próximo ponto.', type: 'active', implemented: true },
                'swap': { id: 'swap', name: 'Troca', icon: '🔁', description: 'Troca a posição de duas peças no tabuleiro.', type: 'active', implemented: true },
                'shove': { id: 'shove', name: 'Empurrão', icon: '🖐️', description: 'Empurra uma peça para uma casa vazia adjacente.', type: 'active', implemented: true },
                'mirror': { id: 'mirror', name: 'Espelho', icon: '🪞', description: 'Cancela a próxima habilidade inimiga.', type: 'active', implemented: true },
            };

            const LEVEL_CONFIG = Array.from({ length: 80 }, (_, i) => {
                const level = i + 1;
                
                // Níveis 1-9: Ato 1 - Treinamento Básico
                if (level <= 9) {
                    return { level, aiName: `Aspirante Nv. ${level}`, aiDifficulty: 'easy', aiSkills: [], mission: { description: "Vença a partida.", isCompleted: (gd) => gd.playerWon } };
                } 
                // Nível 10: Chefe da Cura
                else if (level === 10) {
                    return { level, aiName: "Guardião da Cura", aiDifficulty: 'easy', aiSkills: ['heal'], unlocksSkill: 'heal', mission: { description: "Vença para desbloquear a Cura ❤️‍🩹.", isCompleted: (gd) => gd.playerWon } };
                }
                // Nível 11: Portão do Ato 2
                else if (level === 11) {
                    return { level, aiName: "Guardião do Portão", aiDifficulty: 'normal', aiSkills: ['shield'], gate: { requiredTier: 1, requiredPercentage: 0.8 }, mission: { description: "Prove seu valor para avançar.", isCompleted: (gd) => gd.playerWon } };
                }
                // Níveis 12-19: Ato 2 - O Desafio do Tático (Início)
                else if (level <= 19) {
                    const missions = [ { description: "Vença com mais de 50 de vida.", isCompleted: (gd) => gd.playerWon && gd.playerFinalHealth > 50 }, { description: "Vença em 20 turnos ou menos.", isCompleted: (gd) => gd.playerWon && gd.turnCount <= 20 }, { description: "Vença sem que a IA faça pontos.", isCompleted: (gd) => gd.playerWon && gd.opponentPoints === 0 } ];
                    const names = ["O Estrategista", "O Defensor", "O Tático"];
                    return { level, aiName: names[(level-12) % names.length], aiDifficulty: 'normal', aiSkills: ['heal', 'bomb'], mission: missions[(level - 12) % missions.length] };
                } 
                // Nível 20: Chefe da Bomba
                else if (level === 20) {
                    return { level, aiName: "Mestre das Bombas", aiDifficulty: 'normal', aiSkills: ['bomb', 'shield'], unlocksSkill: 'bomb', mission: { description: "Vença usando a habilidade Cura ❤️‍🩹 para desbloquear a Bomba 💣.", isCompleted: (gd) => gd.playerWon && gd.skillsUsed.includes('heal') } };
                }
                // Nível 21: Portão do Ato 3
                else if (level === 21) {
                    return { level, aiName: "Guardião Tático", aiDifficulty: 'normal', aiSkills: ['sacrifice', 'shield'], gate: { requiredTier: 2, requiredPercentage: 0.8 }, mission: { description: "Mostre sua habilidade tática.", isCompleted: (gd) => gd.playerWon } };
                }
                // Níveis 22-29: Ato 3 - Desafio Tático (Avançado)
                else if (level <= 29) {
                    const missions = [ { description: "Vença com mais de 70 de vida.", isCompleted: (gd) => gd.playerWon && gd.playerFinalHealth > 70 }, { description: "Vença usando Bomba 💣 pelo menos uma vez.", isCompleted: (gd) => gd.playerWon && gd.skillsUsed.includes('bomb') }, { description: "Vença sem que a IA faça mais de 1 ponto.", isCompleted: (gd) => gd.playerWon && gd.opponentPoints <= 1 } ];
                    const names = ["O Defensor Implacável", "O Agressor Calculista", "A Muralha"];
                    return { level, aiName: names[(level-22) % names.length], aiDifficulty: 'normal', aiSkills: ['heal', 'bomb', 'shield'], mission: missions[(level-22) % missions.length] };
                }
                // Nível 30: Chefe do Escudo
                else if (level === 30) {
                    return { level, aiName: "O Protetor da Arena", aiDifficulty: 'normal', aiSkills: ['shield', 'heal'], unlocksSkill: 'shield', mission: { description: "Vença para desbloquear o Escudo 🛡️.", isCompleted: (gd) => gd.playerWon } };
                }
                // Nível 31: Portão do Ato 4
                else if (level === 31) {
                    return { level, aiName: "Guardião dos Enigmas", aiDifficulty: 'hard', aiSkills: ['swap', 'mirror'], gate: { requiredTier: 3, requiredPercentage: 0.8 }, mission: { description: "Resolva este desafio para prosseguir.", isCompleted: (gd) => gd.playerWon } };
                }
                // Níveis 32-39: Ato 4 - Quebra-Cabeça do Mestre
                else if (level <= 39) {
                    const missions = [ { description: "Vença com sua vida abaixo de 40.", isCompleted: (gd) => gd.playerWon && gd.playerFinalHealth < 40 }, { description: "Vença SEM usar a habilidade Bomba 💣.", isCompleted: (gd) => gd.playerWon && !gd.skillsUsed.includes('bomb')}, { description: "Vença SEM usar a habilidade Cura ❤️‍🩹.", isCompleted: (gd) => gd.playerWon && !gd.skillsUsed.includes('heal')} ];
                    const names = ["O Ilusionista", "O Mestre das Restrições", "O Trapaceiro"];
                    return { level, aiName: names[(level-32) % names.length], aiDifficulty: 'hard', aiSkills: ['swap', 'shove', 'mirror'], mission: missions[(level-32) % missions.length] };
                }
                // Nível 40: Chefe do Vampirismo
                else if (level === 40) {
                     return { level, aiName: "O Lorde Sanguinário", aiDifficulty: 'hard', aiSkills: ['vampirism', 'sacrifice'], unlocksSkill: 'vampirism', mission: { description: "Derrote o lorde para aprender a arte do Vampirismo 🩸.", isCompleted: (gd) => gd.playerWon } };
                }
                // Nível 41: Portão do Ato 5
                else if (level === 41) {
                     return { level, aiName: "Guardião do Panteão", aiDifficulty: 'hard', aiSkills: ['mirror', 'shield', 'swap'], gate: { requiredTier: 4, requiredPercentage: 0.8 }, mission: { description: "Apenas os mestres passam daqui.", isCompleted: (gd) => gd.playerWon } };
                }
                // Níveis 42-49: Ato 5 - Quebra-Cabeças do Mestre
                else if (level <= 49) {
                    const missions = [ { description: "Vença com sua vida abaixo de 30.", isCompleted: (gd) => gd.playerWon && gd.playerFinalHealth < 30 }, { description: "Vença um oponente com 120 de vida inicial.", isCompleted: (gd) => gd.playerWon, customInitialHealth: {o: 120} }, { description: "Vença SEM usar habilidades defensivas (Escudo, Espelho).", isCompleted: (gd) => gd.playerWon && !gd.skillsUsed.includes('shield') && !gd.skillsUsed.includes('mirror')} ];
                    const names = ["O Mestre da Confusão", "O Manipulador", "O Arquiteto da Dor"];
                    return { level, aiName: names[(level - 42) % names.length], aiDifficulty: 'hard', aiSkills: ['sacrifice', 'shove', 'mirror'], mission: missions[(level - 42) % missions.length] };
                }
                // Nível 50: Chefe do Sacrifício
                else if (level === 50) {
                    return { level, aiName: "O Lorde do Sacrifício", aiDifficulty: 'hard', aiSkills: ['sacrifice', 'vampirism', 'shield'], unlocksSkill: 'sacrifice', mission: { description: "Domine o poder do sacrifício para desbloquear a habilidade 💀.", isCompleted: (gd) => gd.playerWon } };
                }
                // Nível 51: Portão do Ato 6
                else if (level === 51) {
                    return { level, aiName: "Guardião Enigmático", aiDifficulty: 'hard', aiSkills: ['swap', 'mirror', 'shield'], gate: { requiredTier: 5, requiredPercentage: 0.8 }, mission: { description: "Prove sua maestria tática para avançar.", isCompleted: (gd) => gd.playerWon } };
                }
                // Níveis 52-59: Ato 6 - Desafios do Ilusionista
                else if (level <= 59) {
                    const missions = [ { description: "Vença após usar a habilidade Sacrifício 💀.", isCompleted: (gd) => gd.playerWon && gd.skillsUsed.includes('sacrifice') }, { description: "Vença trocando uma peça sua com uma peça inimiga.", isCompleted: (gd) => gd.playerWon && gd.swappedOwnWithEnemy }, { description: "Vença a partida sem que suas peças ocupem o centro (casa 5).", isCompleted: (gd) => gd.playerWon && !gd.playerUsedCenter} ];
                    const names = ["O Mestre da Troca", "O Ilusionista", "O Estrategista Caótico"];
                     return { level, aiName: names[(level - 52) % names.length], aiDifficulty: 'hard', aiSkills: ['swap', 'shove', 'bomb'], mission: missions[(level - 52) % missions.length] };
                }
                // Nível 60: Chefe da Troca
                else if (level === 60) {
                    return { level, aiName: "O Ilusionista do Tabuleiro", aiDifficulty: 'hard', aiSkills: ['swap', 'mirror', 'shove'], unlocksSkill: 'swap', mission: { description: "Derrote o mestre da ilusão para desbloquear a Troca 🔁.", isCompleted: (gd) => gd.playerWon } };
                }
                // Nível 61: Portão do Ato 7
                else if (level === 61) {
                    return { level, aiName: "Guardião do Panteão", aiDifficulty: 'hard', aiSkills: ['mirror', 'shield', 'swap'], gate: { requiredTier: 6, requiredPercentage: 0.8 }, mission: { description: "Apenas os mestres passam daqui.", isCompleted: (gd) => gd.playerWon } };
                }
                // Níveis 62-69: Ato 7 - Panteão dos Campeões
                else if (level <= 69) {
                    const missions = [ { description: "Vença um oponente Titã com 150 de vida.", isCompleted: (gd) => gd.playerWon, customInitialHealth: {o: 150} }, { description: "Vença sem que a IA faça mais de 1 ponto.", isCompleted: (gd) => gd.playerWon && gd.opponentPoints <= 1 }, { description: "Vença usando 3 habilidades ativas diferentes.", isCompleted: (gd) => gd.playerWon && gd.skillsUsed.length >= 3 } ];
                    const names = ["Lenda Viva", "Titã da Arena", "Campeão Implacável"];
                    return { level, aiName: names[(level - 62) % names.length], aiDifficulty: 'hard', aiSkills: ['swap', 'shove', 'sacrifice', 'shield'], mission: missions[(level - 62) % missions.length] };
                }
                // Nível 70: Chefe do Empurrão
                else if (level === 70) {
                    return { level, aiName: "Mestre do Posicionamento", aiDifficulty: 'hard', aiSkills: ['shove', 'swap', 'bomb'], unlocksSkill: 'shove', mission: { description: "Derrote o mestre da manipulação para desbloquear o Empurrão 🖐️.", isCompleted: (gd) => gd.playerWon } };
                }
                 // Nível 71: Portão do Ato 8
                else if (level === 71) {
                    return { level, aiName: "O Último Guardião", aiDifficulty: 'hard', aiSkills: ['mirror', 'shield', 'shove', 'swap'], gate: { requiredTier: 7, requiredPercentage: 0.8 }, mission: { description: "Apenas a lenda viva pode passar.", isCompleted: (gd) => gd.playerWon } };
                }
                // Níveis 72-79: Ato 8 - O Desafio Final
                 else if (level <= 79) {
                    const missions = [ { description: "Vença um oponente com 200 de vida.", isCompleted: (gd) => gd.playerWon, customInitialHealth: {o: 200} }, { description: "Vença a partida sem que o oponente faça NENHUM ponto.", isCompleted: (gd) => gd.playerWon && gd.opponentPoints === 0 }, { description: "Vença com suas 3 peças em uma diagonal.", isCompleted: (gd) => gd.playerWon && gd.wonOnDiagonal } ];
                    const names = ["A Lenda Suprema", "Deus da Arena", "O Invencível"];
                    return { level, aiName: names[(level - 72) % names.length], aiDifficulty: 'hard', aiSkills: ['mirror', 'shove', 'sacrifice', 'swap', 'shield'], mission: missions[(level - 72) % missions.length] };
                }
                // Nível 80: Chefe Final do Espelho
                else if (level === 80) {
                    return { level, aiName: "O Campeão Supremo", aiDifficulty: 'hard', aiSkills: ['mirror', 'shield', 'swap', 'shove', 'sacrifice'], unlocksSkill: 'mirror', mission: { description: "Derrote a lenda para desbloquear o Espelho 🪞 e completar sua jornada.", isCompleted: (gd) => gd.playerWon } };
                }
                
                return null; // Caso algum nível não seja coberto
            }).filter(Boolean); // Filtra quaisquer valores nulos
            
            // --- STATE VARIABLES ---
            let cellElements, isOTurn, movesX, movesO, healthX, healthO, drainInterval, isGameActive,
                playerToEdit, gameMode = null, selectedSubMode = null, aiDifficulty = 'normal', aiTimeout,
                skills, targetingState = null, eventManager, interdictedCellIndex = -1,
                savedPlayerName = '', currentScreenElement = null, playerSkillKit = [];
            
            let turnCount, playerSkillsUsed, opponentPoints, swappedOwnWithEnemy, playerUsedCenter, wonOnDiagonal;
            
            let playerXAvatar = { ...DEFAULT_AVATAR_X };
            let playerOAvatar = { ...DEFAULT_AVATAR_O };

            let campaignProgress = {
                unlockedSkills: [], 
                completedMissions: [], 
                highestLevelUnlocked: 1,
                unlockedThirdSlot: false // Rastreia o desbloqueio do 3º slot
            };
            let currentLevelData = null; 
            
            // --- MUSIC AND NAVIGATION CONTROL ---
            function playMenuMusic() { stopBattleMusic(); if (menuMusic.paused) menuMusic.play().catch(() => {}); }
            function stopMenuMusic() { menuMusic.pause(); menuMusic.currentTime = 0; }
            function playBattleMusic() { stopMenuMusic(); if (battleMusic.paused) battleMusic.play().catch(() => {}); }
            function stopBattleMusic() { battleMusic.pause(); battleMusic.currentTime = 0; }
            
            function updateMusic(currentScreen) {
                if (currentScreen === gameScreen) {
                    stopMenuMusic();
                    playBattleMusic();
                    historyToggleButton.classList.add('visible');
                } else {
                    stopBattleMusic();
                    playMenuMusic();
                    historyToggleButton.classList.remove('visible');
                    historyPanel.classList.remove('show');
                }
            }
            
            function showScreen(screenToShow, direction = 'forward') {
                if(direction === 'none') {
                    if(currentScreenElement) currentScreenElement.classList.remove('active');
                    screenToShow.classList.add('active');
                    currentScreenElement = screenToShow;
                    updateMusic(screenToShow);
                    return;
                }
                if (currentScreenElement && currentScreenElement !== screenToShow) {
                    const outClass = direction === 'forward' ? 'slide-out-to-left' : 'slide-out-to-right';
                    currentScreenElement.classList.remove('active');
                    currentScreenElement.classList.add(outClass);
                    currentScreenElement.addEventListener('animationend', () => {
                        currentScreenElement.classList.remove(outClass);
                    }, { once: true });
                }
                
                const inClass = direction === 'forward' ? 'slide-in-from-right' : 'slide-in-from-left';
                screenToShow.classList.remove('slide-out-to-left', 'slide-out-to-right');
                screenToShow.classList.add('active', inClass);
                screenToShow.addEventListener('animationend', () => {
                    screenToShow.classList.remove(inClass);
                }, { once: true });
                
                currentScreenElement = screenToShow;
                updateMusic(screenToShow);
                winningMessageElement.classList.remove('show');
            }
            
            // --- HELPER FUNCTIONS ---
            function playSound(sound) { if(sound) { sound.currentTime = 0; sound.play().catch(e => {}); } }
            
            function showNotification(message) {
                notificationText.innerHTML = message;
                notificationModal.classList.add('show');
            }
            
            function getRandomSkills(pool, count) {
                const shuffled = [...pool].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }

            function logAction(message, playerClass = 'system-log') {
                const logEntry = document.createElement('div');
                logEntry.classList.add('log-entry', playerClass);
                logEntry.innerHTML = message;
                historyLogContent.prepend(logEntry);
            }

            function getAdjacentCells(index) {
                const adjacent = [];
                const isTopRow = index < 3;
                const isBottomRow = index > 5;
                const isLeftCol = index % 3 === 0;
                const isRightCol = index % 3 === 2;

                if (!isTopRow) adjacent.push(index - 3); // Top
                if (!isBottomRow) adjacent.push(index + 3); // Bottom
                if (!isLeftCol) adjacent.push(index - 1); // Left
                if (!isRightCol) adjacent.push(index + 1); // Right

                return adjacent.map(i => cellElements[i]).filter(Boolean); // Return valid cell elements
            }
            
            function getMaxKitSize() {
                // Na campanha, o limite é sempre 2 para manter o desafio.
                if (gameMode === 'campaign') {
                    return 2;
                } else {
                    // Para outros modos, verifique se o jogador desbloqueou o slot.
                    return campaignProgress.unlockedThirdSlot ? 3 : 2;
                }
            }

            // --- ARSENAL AND PROFILE LOGIC ---
            function loadData() {
                savedPlayerName = localStorage.getItem('arenaPlayerName');
                const savedAvatarJSON = localStorage.getItem('arenaPlayerAvatar');
                const savedKitJSON = localStorage.getItem('arenaPlayerKit');
                
                if (savedPlayerName) {
                    playerXAvatar = savedAvatarJSON ? JSON.parse(savedAvatarJSON) : { ...DEFAULT_AVATAR_X };
                    playerSkillKit = savedKitJSON ? JSON.parse(savedKitJSON) : [];
                    arsenalPlayerNameInput.value = savedPlayerName;
                    applyAvatar(arsenalCharPreview, playerXAvatar);
                }
                
                loadCampaignProgress();

                if (savedPlayerName) {
                    showScreen(modeSelectMenu, 'none');
                } else {
                    showScreen(arsenalScreen, 'none');
                }
                // Call populateArsenalScreen after everything is loaded
                changeArsenalButton.click(); // Simulate click to open arsenal with correct state
                showScreen(savedPlayerName ? modeSelectMenu : arsenalScreen, 'none'); // Return to correct screen
            }
            
            function populateArsenalScreen() {
                skillDeckGrid.innerHTML = '';
                playerKitSlots.innerHTML = '';
                const maxKitSize = getMaxKitSize();

                playerKitTitle.textContent = `Seu Kit de Batalha (Escolha ${maxKitSize})`;

                const unlockedSkills = campaignProgress.unlockedSkills; 

                if(unlockedSkills.length === 0){
                    skillDeckGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--cor-celula);">Nenhuma habilidade desbloqueada. Jogue o modo Campanha!</p>`;
                } else {
                     unlockedSkills.forEach(skillId => {
                        const skill = ALL_SKILLS[skillId];
                        if (!skill) return;

                        const card = document.createElement('div');
                        card.className = 'skill-card';
                        card.dataset.skillId = skill.id;
                        card.innerHTML = `<div class="skill-icon">${skill.icon}</div><div class="skill-name">${skill.name}</div>`;
                        card.title = skill.description;
                        
                        if (playerSkillKit.includes(skill.id)) card.classList.add('selected');
                        
                        card.addEventListener('click', () => handleSkillSelection(skill.id));
                        skillDeckGrid.appendChild(card);
                    });
                }

                for(let i = 0; i < maxKitSize; i++) {
                    const kitSlot = document.createElement('div');
                    kitSlot.className = 'kit-slot';
                    const skillId = playerSkillKit[i];
                    if (skillId && ALL_SKILLS[skillId]) {
                        const skill = ALL_SKILLS[skillId];
                        kitSlot.innerHTML = `<div class="skill-card selected" title="${skill.description}">
                                                  <div class="skill-icon">${skill.icon}</div>
                                                  <div class="skill-name">${skill.name}</div>
                                              </div>`;
                    }
                    playerKitSlots.appendChild(kitSlot);
                }
            }
            
            function handleSkillSelection(skillId) {
                const skillIndex = playerSkillKit.indexOf(skillId);
                const maxKitSize = getMaxKitSize();
                
                if (skillIndex > -1) {
                    playerSkillKit.splice(skillIndex, 1);
                } else {
                    if (playerSkillKit.length >= maxKitSize) {
                        showNotification(`Seu kit já tem ${maxKitSize} habilidades. Remova uma para adicionar outra.`);
                        return;
                    }
                    playerSkillKit.push(skillId);
                }
                populateArsenalScreen();
            }
            
            function saveArsenalAndProceed() {
                const name = arsenalPlayerNameInput.value.trim();
                
                if (name) {
                    savedPlayerName = name;
                    localStorage.setItem('arenaPlayerName', name);
                    localStorage.setItem('arenaPlayerAvatar', JSON.stringify(playerXAvatar));
                    localStorage.setItem('arenaPlayerKit', JSON.stringify(playerSkillKit));
                    showScreen(modeSelectMenu, 'forward');
                } else {
                     showNotification('Por favor, digite seu nome de jogador.');
                }
            }

            // --- CAMPAIGN LOGIC ---
            function saveCampaignProgress() {
                localStorage.setItem('arenaCampaignProgress', JSON.stringify(campaignProgress));
            }

            function loadCampaignProgress() {
                const savedProgress = localStorage.getItem('arenaCampaignProgress');
                if (savedProgress) {
                    campaignProgress = JSON.parse(savedProgress);
                }
            }

            function showCampaignMap() {
                campaignLevelGrid.innerHTML = ''; 

                LEVEL_CONFIG.forEach(levelData => {
                    if (!levelData) return;
                    const levelButton = document.createElement('button');
                    levelButton.className = 'menu-button';
                    levelButton.innerHTML = `${levelData.level}<br><small style="font-size: 0.7rem; font-weight: 400;">${levelData.aiName}</small>`;

                    let isLocked = levelData.level > campaignProgress.highestLevelUnlocked;

                    if (levelData.gate && isLocked) {
                        const { requiredTier, requiredPercentage } = levelData.gate;
                        const tierStart = (requiredTier - 1) * 10 + 1;
                        const tierEnd = requiredTier * 10;
                        
                        const tierLevels = LEVEL_CONFIG.filter(l => l && l.level >= tierStart && l.level <= tierEnd);
                        const completedInTier = tierLevels.filter(l => campaignProgress.completedMissions.includes(l.level)).length;
                        
                        const currentPercentage = tierLevels.length > 0 ? (completedInTier / tierLevels.length) : 0;

                        if (currentPercentage >= requiredPercentage) {
                            isLocked = false;
                            if (levelData.level > campaignProgress.highestLevelUnlocked) {
                                campaignProgress.highestLevelUnlocked = levelData.level;
                                saveCampaignProgress();
                            }
                        } else {
                             levelButton.title = `Complete ${Math.round(requiredPercentage * 100)}% (${completedInTier}/${tierLevels.length}) das missões do Ato ${tierStart}-${tierEnd} para desbloquear.`;
                             levelButton.innerHTML += ` <span style="font-size: 1.2rem; display: block;">🔒</span>`;
                        }
                    }

                    if (isLocked) {
                        levelButton.disabled = true;
                    } else {
                        if (campaignProgress.completedMissions.includes(levelData.level)) {
                            levelButton.classList.add('mission-complete');
                            levelButton.innerHTML += ` <span style="font-size: 0.8rem; display: block;">✔️</span>`;
                        } else {
                            levelButton.title = `Missão: ${levelData.mission.description}`;
                        }
                        levelButton.addEventListener('click', () => startCampaignLevel(levelData.level));
                    }
                    
                    campaignLevelGrid.appendChild(levelButton);
                });
                showScreen(campaignMapScreen, 'forward');
            }

            function startCampaignLevel(levelNumber) {
                currentLevelData = LEVEL_CONFIG.find(l => l && l.level === levelNumber);
                if (!currentLevelData) return;

                gameMode = 'campaign';
                aiDifficulty = currentLevelData.aiDifficulty;
                
                initializeMatch();
                showScreen(gameScreen, 'forward');
            }
            
            function handleCampaignEnd(gameData) {
                const missionAccomplished = currentLevelData.mission.isCompleted(gameData);
                let message = "";

                if (gameData.playerWon) {
                    if (missionAccomplished) {
                        message = `Missão Cumprida!`;
                        if (!campaignProgress.completedMissions.includes(currentLevelData.level)) {
                            campaignProgress.completedMissions.push(currentLevelData.level);
                        }
                        
                        const nextLevel = currentLevelData.level + 1;
                        const nextLevelData = LEVEL_CONFIG.find(l => l && l.level === nextLevel);
                        if (nextLevel > campaignProgress.highestLevelUnlocked && nextLevelData && !nextLevelData.gate) {
                             campaignProgress.highestLevelUnlocked = nextLevel;
                        }


                        if (currentLevelData.unlocksSkill) {
                            const skillId = currentLevelData.unlocksSkill;
                            if (!campaignProgress.unlockedSkills.includes(skillId)) {
                                campaignProgress.unlockedSkills.push(skillId);
                                const skill = ALL_SKILLS[skillId];
                                message += `<br><br><small>Nova Habilidade: ${skill.icon} ${skill.name}!</small>`;
                            }
                        }
                    } else {
                        message = `Vitória! <br><small>(Missão: ${currentLevelData.mission.description} - Falhou)</small>`;
                    }

                    // Lógica para desbloquear o 3º slot
                    if (currentLevelData.level === 35 && !campaignProgress.unlockedThirdSlot) {
                        campaignProgress.unlockedThirdSlot = true;
                        const notificationMessage = `<h3>Arsenal Expandido!</h3>
                                                     <p>Você provou seu valor tático. Como recompensa, o 3º slot de habilidade foi desbloqueado para os modos **Batalha Tática** e **Partida Rápida**!</p>
                                                     <p><i>(Na Campanha, o desafio continua com 2 slots).</i></p>`;
                        showNotification(notificationMessage.replace(/\n\s+/g, '\n'));
                    }

                } else {
                    message = `Derrota!`;
                }

                saveCampaignProgress();

                winningMessageTextElement.innerHTML = message;
                winningMessageElement.classList.add('show');
                
                const winner = gameData.playerWon ? charX : charO;
                const loser = gameData.playerWon ? charO : charX;
                const winnerColor = gameData.playerWon ? 'var(--cor-x)' : 'var(--cor-o)';
                winner.style.setProperty('--winner-color', winnerColor);
                winner.classList.add('victory');
                loser.classList.add('defeat');
                boardElement.classList.add('locked');
            }
            
            // --- CORE GAME LOGIC ---
            function initializeMatch() {
                isGameActive = true;
                healthX = 100; healthO = 100;
                
                if(gameMode === 'campaign' && currentLevelData && currentLevelData.customInitialHealth) {
                    healthX = currentLevelData.customInitialHealth.x || 100;
                    healthO = currentLevelData.customInitialHealth.o || 100;
                }

                isOTurn = false; movesX = []; movesO = [];
                targetingState = null;
                interdictedCellIndex = -1;
                turnCount = 0;
                playerSkillsUsed = { x: [], o: [] };
                opponentPoints = 0;
                swappedOwnWithEnemy = false;
                playerUsedCenter = false;
                wonOnDiagonal = false;

                historyLogContent.innerHTML = '';
                logAction('A batalha começou!');
                
                charX.className = 'character'; charO.className = 'character';
                charX.style.removeProperty('--player-color'); charO.style.removeProperty('--player-color');
                
                clearInterval(drainInterval); clearTimeout(aiTimeout);
                if(eventManager) eventManager.stop();
                eventManager = null;
                drainInterval = setInterval(drainHealth, 1000);
                
                boardElement.className = 'board';
                boardElement.innerHTML = '';
                for(let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.cellIndex = i;
                    boardElement.appendChild(cell);
                }
                cellElements = Array.from(boardElement.querySelectorAll('.cell'));
                
                const clickHandler = {
                    'local': handleLocalClick, 
                    'single': handleVsAiClick,
                    'tatico': handleTaticoClick, 
                    'caotico': handleTaticoClick, // Uses tatico logic for base moves
                    'tatico_single': handleTaticoClick, 
                    'caotico_single': handleTaticoClick, // Uses tatico logic for base moves
                    'campaign': handleTaticoClick,
                }[gameMode];
                
                cellElements.forEach(cell => cell.addEventListener('click', clickHandler));
                
                setupGameUI();
                updateHealthBars();
                updateOldestPieceIndicator();
                
                winningLaserLine.classList.remove('winning-laser-active');
                boardElement.classList.remove('dimmed-board');
                cellElements.forEach(cell => {
                    cell.classList.remove('winning-cell-pulse');
                    cell.style.removeProperty('--pulse-color');
                });
                
                setTimeout(showTurnAnnouncement, 500);
            }
            
            function setupGameUI() {
                const isVsAi = gameMode.includes('single') || gameMode === 'campaign';
                gamePlayerLabelX.innerText = savedPlayerName || 'Jogador X';
                
                if (isVsAi) {
                    if (gameMode === 'campaign' && currentLevelData) {
                        gamePlayerLabelO.innerText = currentLevelData.aiName;
                        playerOAvatar = { type: 'emoji', value: '🤖' };
                    } else {
                        playerNameOInput.value = `Máquina (${aiDifficulty})`;
                        gamePlayerLabelO.innerText = playerNameOInput.value;
                        playerOAvatar = { type: 'emoji', value: '🤖' };
                    }
                } else {
                    if (!playerNameOInput.value) playerNameOInput.value = 'Jogador O';
                    gamePlayerLabelO.innerText = playerNameOInput.value;
                }
                
                applyAvatar(charX, playerXAvatar);
                applyAvatar(charO, playerOAvatar);
                
                const isTatic = gameMode.startsWith('tatico') || gameMode.startsWith('caotico') || gameMode === 'campaign';
                skillsMainContainer.classList.toggle('show', isTatic);
                skillsOContainer.style.visibility = 'visible';
                
                if (isTatic) {
                    skills = {
                        x: { shieldActive: false, damageBoostActive: false, mirrorActive: false },
                        o: { shieldActive: false, damageBoostActive: false, mirrorActive: false }
                    };
                    
                    playerSkillKit.forEach(skillId => { 
                         if(ALL_SKILLS[skillId]) skills.x[skillId] = true; 
                    });
                
                    if (isVsAi) {
                        let aiSkillsList = [];
                        if (gameMode === 'campaign') {
                            aiSkillsList = currentLevelData.aiSkills;
                        } else {
                            let numberOfAiSkills = aiDifficulty === 'hard' ? 3 : aiDifficulty === 'normal' ? 2 : 1;
                            aiSkillsList = getRandomSkills(AI_SKILL_POOL, numberOfAiSkills);
                        }
                        
                        aiSkillsList.forEach(skillId => {
                            if (ALL_SKILLS[skillId]) skills.o[skillId] = true;
                        });
                        if (aiSkillsList.length > 0) {
                            logAction(`A IA entra na batalha com: ${aiSkillsList.map(id => ALL_SKILLS[id]?.icon || '').join(' ')}`);
                        }

                    } else { 
                        // For local tatic mode, give default skills to player O
                        getRandomSkills(campaignProgress.unlockedSkills, getMaxKitSize()).forEach(skillId => {
                            if(ALL_SKILLS[skillId]) skills.o[skillId] = true;
                        });
                    }
                    
                    setupSkillButtons();
                }
                
                if (gameMode.startsWith('caotico')) {
                    // This part can be expanded later
                }
                updateTurnIndicator();
            }
            
            function setupSkillButtons() {
                skillsXContainer.innerHTML = '';
                skillsOContainer.innerHTML = '';
                
                const createButton = (skill, playerClass) => {
                    const button = document.createElement('button');
                    button.className = 'skill-button';
                    button.innerHTML = skill.icon;
                    
                    if (skill.type === 'active') {
                        button.id = `${skill.id}-${playerClass}`;
                        button.title = `${skill.name}: ${skill.description}`;
                        if (skill.implemented && playerClass === X_CLASS) { // Only player X can click
                            button.addEventListener('click', () => {
                                const skillActions = {
                                    'bomb': () => activateBomb(X_CLASS, 'bomb'), 'heal': () => activateHeal(X_CLASS, 'heal'),
                                    'shield': () => activateShield(X_CLASS, 'shield'), 'sacrifice': () => activateSacrifice(X_CLASS, 'sacrifice'),
                                    'mirror': () => activateMirror(X_CLASS, 'mirror'), 'swap': () => activateSwap(X_CLASS, 'swap'),
                                    'shove': () => activateShove(X_CLASS, 'shove'),
                                };
                                skillActions[skill.id]?.();
                            });
                        } else {
                            button.disabled = true;
                        }
                    } else { // Passive skills
                        button.id = `${skill.id}-indicator-${playerClass}`;
                        button.title = `${skill.name} (Passiva): ${skill.description}`;
                        button.disabled = true;
                        button.style.cursor = 'help';
                    }
                    return button;
                }

                Object.keys(skills.x).forEach(skillId => {
                     if (skills.x[skillId] === true && ALL_SKILLS[skillId]) {
                         skillsXContainer.appendChild(createButton(ALL_SKILLS[skillId], X_CLASS));
                     }
                });
                
                Object.keys(skills.o).forEach(skillId => {
                    if (skills.o[skillId] === true && ALL_SKILLS[skillId]) { 
                        skillsOContainer.appendChild(createButton(ALL_SKILLS[skillId], O_CLASS));
                    }
                });
                
                updateSkillButtonsState();
            }
            
            function drainHealth() {
                if (!isGameActive) return;
                if (isOTurn) { if (healthO > 0) healthO = Math.max(0, healthO - HEALTH_DRAIN_PER_SECOND); }
                else { if (healthX > 0) healthX = Math.max(0, healthX - HEALTH_DRAIN_PER_SECOND); }
                updateHealthBars();
                if (healthX <= 0 || healthO <= 0) endGame();
            }
            
            function clearInterdiction() {
                if (interdictedCellIndex !== -1) {
                    const interdictedCell = cellElements[interdictedCellIndex];
                    if (interdictedCell) interdictedCell.classList.remove('interdicted');
                    interdictedCellIndex = -1;
                    logAction("Interdição da célula removida.", 'system-log');
                }
            }
            
            function showTurnAnnouncement() {
                if (!isGameActive) return;
                const currentPlayerName = isOTurn ? (gamePlayerLabelO.innerText) : (savedPlayerName || 'Jogador X');
                turnAnnouncementText.textContent = `Turno de ${currentPlayerName}`;
                turnAnnouncementContainer.classList.add('show');
                turnAnnouncementContainer.addEventListener('animationend', () => {
                    turnAnnouncementContainer.classList.remove('show');
                }, { once: true });
            }
            
            function applyDamageEffects(winnerClass, damage) {
                if (winnerClass === X_CLASS) healthO = Math.max(0, healthO - damage);
                else healthX = Math.max(0, healthX - damage);
                
                updateHealthBars();
                
                if (healthX <= 0 || healthO <= 0) {
                    endGame();
                } else {
                    const healthBgToAnimate = winnerClass === X_CLASS ? healthBgO : healthBgX;
                    healthBgToAnimate.classList.add('damage');
                    setTimeout(() => healthBgToAnimate.classList.remove('damage'), 500);
            
                    playSound(attackSound);
                    setTimeout(() => {
                        playSound(hitSound);
                        triggerAnimation(winnerClass === X_CLASS ? charX : charO, winnerClass === X_CLASS ? charO : charX, winnerClass === X_CLASS);
                        if (isGameActive) {
                            swapTurns();
                        }
                    }, 300);
                }
            }
            
            function swapTurns() {
                turnCount++;
                isOTurn = !isOTurn;
                updateTurnIndicator();
                showTurnAnnouncement();
                if (isGameActive && isOTurn && (gameMode.includes('single') || gameMode === 'campaign')) {
                    triggerAiTurn();
                }
            }
            
            function triggerAnimation(attacker, defender, isXAttacking) {
                const attackDir = isXAttacking ? '30px' : '-30px';
                const hitDir = isXAttacking ? '-15px' : '15px';
                attacker.style.setProperty('--translate-x', attackDir);
                defender.style.setProperty('--translate-x', hitDir);
                attacker.classList.add('attack');
                defender.classList.add('hit');
                setTimeout(() => {
                    attacker.classList.remove('attack');
                    defender.classList.remove('hit');
                }, 600);
            }
            
            function handleDamage(winnerClass, damage = DAMAGE_PER_POINT, winningCombo = null) {
                if(winnerClass === O_CLASS) opponentPoints++;

                const defenderClass = winnerClass === X_CLASS ? O_CLASS : X_CLASS;
                const winnerSkills = winnerClass === X_CLASS ? skills.x : skills.o;
                const defenderSkills = defenderClass === X_CLASS ? skills.x : skills.o;
                let finalDamage = damage;
                
                logAction(`PONTO PARA ${winnerClass.toUpperCase()}!`, `player-${winnerClass}-log`);

                // Check for Sacrifice buff
                if (winnerSkills.damageBoostActive) {
                    finalDamage *= 2;
                    winnerSkills.damageBoostActive = false;
                    const winnerChar = winnerClass === X_CLASS ? charX : charO;
                    winnerChar.classList.remove('damage-boost');
                    logAction(`Sacrifício 💀 dobra o dano para ${finalDamage}!`, `player-${winnerClass}-log`);
                }

                if ((gameMode.startsWith('tatico') || gameMode === 'campaign') && defenderSkills.shieldActive) {
                    logAction(`Escudo 🛡️ de ${defenderClass.toUpperCase()} bloqueia o ataque!`, `player-${defenderClass}-log`);
                    playSound(shieldSound);
                    defenderSkills.shieldActive = false;
                    const defenderChar = defenderClass === X_CLASS ? charX : charO;
                    defenderChar.classList.remove('shielded');
                    updateSkillButtonsState();
                    setTimeout(() => swapTurns(), 500);
                    return;
                }

                // Vampirism Logic
                if (winnerSkills.vampirism) {
                    const healAmount = Math.floor(finalDamage * 0.5);
                    if (winnerClass === X_CLASS) {
                        healthX = Math.min(100, healthX + healAmount);
                    } else {
                        healthO = Math.min(100, healthO + healAmount);
                    }
                    logAction(`Vampirismo 🩸 cura ${healAmount} de vida para ${winnerClass.toUpperCase()}.`, `player-${winnerClass}-log`);
                    playSound(healSound);
                    updateHealthBars();
                }
                
                if (winningCombo) {
                    boardElement.classList.add('locked', 'dimmed-board');
                    drawWinningLaserLine(winnerClass, winningCombo);
                    setTimeout(() => {
                        boardElement.classList.remove('dimmed-board', 'locked');
                        winningLaserLine.classList.remove('winning-laser-active');
                        winningCombo.forEach(index => {
                             cellElements[index].classList.remove('winning-cell-pulse');
                             cellElements[index].style.removeProperty('--pulse-color');
                        });
                        applyDamageEffects(winnerClass, finalDamage);
                    }, 1500);
                } else {
                    applyDamageEffects(winnerClass, finalDamage);
                }
            }
            
            function endGame() {
                isGameActive = false;
                stopBattleMusic();
                clearInterval(drainInterval); 
                clearTimeout(aiTimeout);
                if(eventManager) eventManager.stop();
                
                const playerWon = healthO <= 0 && healthX > 0;

                if (gameMode === 'campaign') {
                    const gameData = {
                        playerWon: playerWon,
                        playerFinalHealth: healthX,
                        opponentFinalHealth: healthO,
                        turnCount: turnCount,
                        skillsUsed: playerSkillsUsed.x,
                        opponentPoints: opponentPoints,
                        swappedOwnWithEnemy: swappedOwnWithEnemy,
                        playerUsedCenter: movesX.some(cell => cell.dataset.cellIndex === '4'),
                        wonOnDiagonal: wonOnDiagonal
                    };
                    handleCampaignEnd(gameData);
                    return;
                }
                
                playSound(victorySound);
                const winner = playerWon ? charX : charO;
                const loser = playerWon ? charO : charX;
                const winnerColor = playerWon ? 'var(--cor-x)' : 'var(--cor-o)';
                
                winner.style.setProperty('--winner-color', winnerColor);
                winner.classList.add('victory');
                loser.classList.add('defeat');
                
                const winnerName = playerWon ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText;
                winningMessageTextElement.innerText = `${winnerName} venceu!`;
                winningMessageElement.classList.add('show');
                boardElement.classList.add('locked');
            }
            
            function updateTurnIndicator() {
                healthContainerX.classList.toggle('active', !isOTurn);
                healthContainerO.classList.toggle('active', isOTurn);
                charX.classList.toggle('turn-active', !isOTurn);
                charO.classList.toggle('turn-active', isOTurn);
                
                if (!isOTurn) charX.style.setProperty('--player-color', 'var(--cor-x)');
                else charO.style.setProperty('--player-color', 'var(--cor-o)');
                
                if(gameMode.startsWith('tatico') || gameMode === 'campaign' || gameMode.startsWith('caotico')) updateSkillButtonsState();
            }
            
            function updateHealthBars() {
                let maxHealthX = 100;
                let maxHealthO = 100;
                if(gameMode === 'campaign' && currentLevelData && currentLevelData.customInitialHealth) {
                    maxHealthX = currentLevelData.customInitialHealth.x || 100;
                    maxHealthO = currentLevelData.customInitialHealth.o || 100;
                }
                healthBarX.style.width = `${(healthX / maxHealthX) * 100}%`;
                healthBarO.style.width = `${(healthO / maxHealthO) * 100}%`;
            }
            
            function checkWin(currentClass, currentMoves) {
                const playerMoves = currentMoves.map(el => parseInt(el.dataset.cellIndex));
                if (playerMoves.length < 3) return { hasWon: false, combo: null };
                for (const combo of WINNING_COMBINATIONS) {
                    if (combo.every(i => playerMoves.includes(i))) {
                        return { hasWon: true, combo: combo };
                    }
                }
                return { hasWon: false, combo: null };
            }
            
            function placeMark(cell, currentClass) {
                playSound(clickSound);
                const currentMoves = currentClass === X_CLASS ? movesX : movesO;
                const playerName = currentClass === X_CLASS ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText;
                logAction(`${playerName} marca a casa ${parseInt(cell.dataset.cellIndex) + 1}.`, `player-${currentClass}-log`);
                
                clearInterdiction();
                
                if (currentMoves.length >= MAX_MOVES) {
                    const oldestCell = currentMoves.shift();
                    oldestCell.classList.remove(X_CLASS, O_CLASS, 'oldest-piece');
                }
                
                cell.classList.add(currentClass);
                currentMoves.push(cell);
                
                if(currentClass === X_CLASS && cell.dataset.cellIndex === '4') {
                    playerUsedCenter = true;
                }

                updateOldestPieceIndicator();
                
                const winResult = checkWin(currentClass, currentMoves);
                if (winResult.hasWon) {
                    if (currentClass === X_CLASS) {
                        const diagonalCombos = [[0,4,8], [2,4,6]];
                        wonOnDiagonal = diagonalCombos.some(c => c.every(i => winResult.combo.includes(i)));
                    }
                    handleDamage(currentClass, DAMAGE_PER_POINT, winResult.combo);
                } else if(isGameActive) {
                    swapTurns();
                }
            }
            
            function handleVsAiClick(e) {
                if (isOTurn || !isGameActive) return;
                handleTaticoClick(e);
            }
            
            function handleLocalClick(e) {
                const cell = e.target;
                if (!isGameActive || cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS) || cell.classList.contains('interdicted')) return;
                const currentClass = isOTurn ? O_CLASS : X_CLASS;
                placeMark(cell, currentClass);
            }
            
            function handleTaticoClick(e) {
                const cell = e.target;
                if (targetingState) {
                    if (targetingState.skill === 'sacrifice') {
                        handleSacrificeExecution(cell);
                    } else if (targetingState.skill === 'swap') {
                        if (targetingState.step === 1) {
                             if(cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS)) {
                                 targetingState.firstCell = cell;
                                 targetingState.step = 2;
                                 cell.classList.add('swap-first-pick');
                                 logAction("Primeira peça selecionada para troca. Selecione a segunda.", "system-log");
                             }
                        } else if (targetingState.step === 2) {
                             if(cell !== targetingState.firstCell && (cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS))) {
                                handleSwapExecution(targetingState.firstCell, cell);
                             }
                        }
                    } else if (targetingState.skill === 'shove') {
                        if (targetingState.step === 1) {
                            if (cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS)) {
                                targetingState.pieceToMove = cell;
                                targetingState.step = 2;
                                logAction("Peça selecionada. Agora escolha uma casa vazia adjacente para empurrá-la.", "system-log");
                                updateShoveTargets(cell);
                            }
                        } else if (targetingState.step === 2) {
                            if (cell.classList.contains('targetable')) {
                                handleShoveExecution(targetingState.pieceToMove, cell);
                            } else if (cell !== targetingState.pieceToMove && (cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS))) {
                                // Allow re-selecting the piece to move
                                updateShoveTargets(cell, true); // true to clear previous origin
                                targetingState.pieceToMove = cell;
                                logAction("Nova peça selecionada. Escolha uma casa vazia adjacente.", "system-log");
                            }
                        }
                    }
                    return;
                }

                const cellIndex = parseInt(cell.dataset.cellIndex);
                if (!isGameActive || cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS) || cellIndex === interdictedCellIndex) {
                    return;
                }
                const currentClass = isOTurn ? O_CLASS : X_CLASS;
                placeMark(cell, currentClass);
            }
            
            function wouldWin(currentClass, potentialCell, currentMoves) {
                const currentMoveIndices = currentMoves.map(el => parseInt(el.dataset.cellIndex));
                const potentialMoveIndices = [...currentMoveIndices, parseInt(potentialCell.dataset.cellIndex)];
                if (potentialMoveIndices.length > MAX_MOVES) {
                    potentialMoveIndices.shift();
                }
                return WINNING_COMBINATIONS.some(combo => combo.every(index => potentialMoveIndices.includes(index)));
            }

            // --- AI LOGIC ---

            // =========================================================================
            // AI Difficulty Level - Easy
            // Behavior: Makes a completely random move from available cells.
            // =========================================================================
            function aiMoveFacil() {
                const availableCells = cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && c.dataset.cellIndex != interdictedCellIndex);
                
                if (availableCells.length > 0) {
                    const randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
                    placeMark(randomCell, O_CLASS);
                } else {
                    logAction("A IA (Fácil) não tem movimentos e passa o turno.", 'player-o-log');
                    swapTurns();
                }
                boardElement.classList.remove('locked');
            }

            // =========================================================================
            // AI Difficulty Level - Normal
            // Behavior: Follows a simple set of rules: Win > Block > Center > Corner > Random.
            // Does not use skills strategically.
            // =========================================================================
            function aiMoveNormal() {
                const availableCells = cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && c.dataset.cellIndex != interdictedCellIndex);

                // 1. Win now with a normal move
                const winningMove = availableCells.find(cell => wouldWin(O_CLASS, cell, movesO));
                if (winningMove) {
                    placeMark(winningMove, O_CLASS);
                    boardElement.classList.remove('locked');
                    return;
                }

                // 2. Block player's win with a normal move
                const blockingMove = availableCells.find(cell => wouldWin(X_CLASS, cell, movesX));
                if (blockingMove) {
                    placeMark(blockingMove, O_CLASS);
                    boardElement.classList.remove('locked');
                    return;
                }
                
                // 3. Take the center
                const centerCell = availableCells.find(cell => cell.dataset.cellIndex === '4');
                if (centerCell) {
                    placeMark(centerCell, O_CLASS);
                    boardElement.classList.remove('locked');
                    return;
                }

                // 4. Take a corner
                const corners = [0, 2, 6, 8].map(i => cellElements[i]).filter(c => availableCells.includes(c));
                if (corners.length > 0) {
                    const randomCorner = corners[Math.floor(Math.random() * corners.length)];
                    placeMark(randomCorner, O_CLASS);
                    boardElement.classList.remove('locked');
                    return;
                }

                // 5. If all else fails, make a random move
                if (availableCells.length > 0) {
                    const randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
                    placeMark(randomCell, O_CLASS);
                } else {
                    logAction("A IA (Normal) não tem movimentos e passa o turno.", 'player-o-log');
                    swapTurns();
                }
                boardElement.classList.remove('locked');
            }


            // =========================================================================
            // AI Difficulty Level - Hard
            // Behavior: Strategic thinking, uses skills.
            // =========================================================================
            function getAiDificilDecision() {
                const availableCells = cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && c.dataset.cellIndex != interdictedCellIndex);
                const aiSkills = skills.o;
                const playerSkills = skills.x;

                // 1. Check for winning moves with skills (Complex logic can be added later)
                
                // 2. Win now with a normal move
                const winningMove = availableCells.find(cell => wouldWin(O_CLASS, cell, movesO));
                if (winningMove) return { type: 'move', cell: winningMove };

                // 3. Block player's win with skills (Complex logic can be added later)
                
                // 4. Block player's win with a normal move
                const blockingMove = availableCells.find(cell => wouldWin(X_CLASS, cell, movesX));
                if (blockingMove) return { type: 'move', cell: blockingMove };

                // 5. Use skills intelligently
                if (aiSkills.heal && healthO < 40 && !playerSkillsUsed.o.includes('heal')) return { type: 'skill_heal' };
                
                const playerIsAboutToWin = availableCells.some(cell => wouldWin(X_CLASS, cell, movesX));
                if (aiSkills.mirror && !aiSkills.mirrorActive && playerSkillsUsed.x.length < getMaxKitSize()) {
                    return { type: 'skill_mirror' };
                }
                if (aiSkills.shield && !aiSkills.shieldActive && playerIsAboutToWin && !playerSkillsUsed.o.includes('shield')) {
                    return { type: 'skill_shield' };
                }
                if (aiSkills.sacrifice && !playerSkillsUsed.o.includes('sacrifice') && healthX < 45 && movesO.length > 0) {
                     const sacrificable = movesO[0];
                     if(sacrificable) return { type: 'skill_sacrifice', cell: sacrificable };
                }
                
                // 6. Default move logic (Center > Corner > Random)
                if (availableCells.length > 0) {
                    const center = cellElements[4];
                    if (availableCells.includes(center)) return { type: 'move', cell: center };
                    const corners = [0, 2, 6, 8].map(i => cellElements[i]).filter(c => availableCells.includes(c));
                    if (corners.length > 0) return { type: 'move', cell: corners[Math.floor(Math.random() * corners.length)] };
                    return { type: 'move', cell: availableCells[Math.floor(Math.random() * availableCells.length)] };
                }
                
                return { type: 'pass' }; // No possible moves
            }

            function aiMoveDificil() {
                const action = getAiDificilDecision();
                
                switch (action.type) {
                    case 'move':
                        placeMark(action.cell, O_CLASS);
                        break;
                    case 'skill_heal':
                        activateHeal(O_CLASS, 'heal');
                        break;
                    case 'skill_shield':
                        activateShield(O_CLASS, 'shield');
                        break;
                    case 'skill_mirror':
                        activateMirror(O_CLASS, 'mirror');
                        break;
                    case 'skill_sacrifice':
                        handleSacrificeExecution(action.cell);
                        break;
                    case 'skill_swap':
                        handleSwapExecution(action.cell1, action.cell2);
                        break;
                    case 'pass':
                    default:
                        logAction("A IA (Difícil) não tem ações e passa o turno.", 'player-o-log');
                        swapTurns();
                        break;
                }
                boardElement.classList.remove('locked');
            }
            
            // =========================================================================
            // AI Controller - Selects the correct AI function based on difficulty
            // =========================================================================
            function triggerAiTurn() {
                if (isGameActive && isOTurn && (gameMode.includes('single') || gameMode === 'campaign')) {
                    boardElement.classList.add('locked');
                    
                    let aiMoveHandler;

                    // Choose the AI logic based on the difficulty setting
                    if (aiDifficulty === 'easy') {
                        aiMoveHandler = aiMoveFacil;
                    } else if (aiDifficulty === 'normal') {
                        aiMoveHandler = aiMoveNormal;
                    } else { // 'hard'
                        aiMoveHandler = aiMoveDificil;
                    }
                    
                    aiTimeout = setTimeout(aiMoveHandler, 1000 + Math.random() * 500);
                }
            }

            // --- SKILL FUNCTIONS ---

             function activateHeal(player, skillId) {
                 if (!isGameActive) return;
                 if (handleMirrorReflection(player, skillId)) return;
                 
                 const isPlayerX = player === X_CLASS;
                 if (playerSkillsUsed[isPlayerX ? 'x' : 'o'].includes(skillId)) return;
                 
                 let currentHealth = isPlayerX ? healthX : healthO;
                 let maxHealth = 100;
                 if (gameMode === 'campaign' && currentLevelData && currentLevelData.customInitialHealth) {
                     maxHealth = isPlayerX ? (currentLevelData.customInitialHealth.x || 100) : (currentLevelData.customInitialHealth.o || 100);
                 }

                 if (currentHealth >= maxHealth) {
                      if(isPlayerX) showNotification("Sua vida já está cheia!");
                      return;
                 }
                 
                 const healthToSet = Math.min(maxHealth, currentHealth + HEAL_AMOUNT);
                 if (isPlayerX) healthX = healthToSet;
                 else healthO = healthToSet;
                 
                 playerSkillsUsed[isPlayerX ? 'x' : 'o'].push(skillId);
                 
                 logAction(`${isPlayerX ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText} usa Cura ❤️‍🩹 e recupera ${HEAL_AMOUNT} de vida.`, `player-${player}-log`);
                 playSound(healSound);
                 updateHealthBars();
                 updateSkillButtonsState();

                 if(!isPlayerX){
                      setTimeout(() => swapTurns(), 500);
                 } else {
                      swapTurns();
                 }
             }

             function activateBomb(player, skillId){ 
                 if (handleMirrorReflection(player, skillId)) return;
                 //... full logic remains the same
             }
             
             function activateShield(player, skillId){ 
                 if (!isGameActive) return;
                 const playerSkills = player === X_CLASS ? skills.x : skills.o;
                 if(playerSkills.shieldActive || playerSkillsUsed[player === X_CLASS ? 'x' : 'o'].includes(skillId)) return;
                 if (handleMirrorReflection(player, skillId)) return;

                 playerSkills.shieldActive = true;
                 playerSkillsUsed[player === X_CLASS ? 'x' : 'o'].push(skillId);

                 const charElement = player === X_CLASS ? charX : charO;
                 charElement.classList.add('shielded');
                 logAction(`${player === X_CLASS ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText} ativa o Escudo 🛡️.`, `player-${player}-log`);
                 playSound(shieldSound);
                 updateSkillButtonsState();

                 if(player === O_CLASS){
                       setTimeout(() => swapTurns(), 500);
                 } else {
                      swapTurns();
                 }
             }

            function activateSacrifice(player, skillId) {
                if (!isGameActive || playerSkillsUsed[player === X_CLASS ? 'x' : 'o'].includes(skillId) || targetingState) return;
                if (handleMirrorReflection(player, skillId)) return;
                
                targetingState = { skill: 'sacrifice', player: player };
                boardElement.classList.add('targeting', 'targeting-sacrifice');
                boardElement.classList.toggle('is-x-turn', player === X_CLASS);
                boardElement.classList.toggle('is-o-turn', player === O_CLASS);

                logAction("Selecione uma de suas peças para sacrificar.", "system-log");
                updateSkillButtonsState();
            }

            function handleSacrificeExecution(cell) {
                if (!targetingState || targetingState.skill !== 'sacrifice') return;
                
                const player = targetingState.player;
                const isPlayerX = player === X_CLASS;
                const cellIsX = cell.classList.contains(X_CLASS);
                const cellIsO = cell.classList.contains(O_CLASS);

                if ((isPlayerX && !cellIsX) || (!isPlayerX && !cellIsO)) {
                    if(isPlayerX) showNotification("Você só pode sacrificar suas próprias peças!");
                    return;
                }

                playerSkillsUsed[player].push('sacrifice');

                const moves = isPlayerX ? movesX : movesO;
                const moveIndex = moves.indexOf(cell);
                if (moveIndex > -1) moves.splice(moveIndex, 1);
                
                cell.classList.remove(X_CLASS, O_CLASS, 'oldest-piece');

                skills[player].damageBoostActive = true;
                const charElement = isPlayerX ? charX : charO;
                charElement.classList.add('damage-boost');

                logAction(`${isPlayerX ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText} sacrifica uma peça 💀 para dobrar o próximo dano!`, `player-${player}-log`);
                playSound(bombSound);

                resetTargetingMode();
                updateOldestPieceIndicator();

                if (isPlayerX) {
                    swapTurns();
                } else {
                    setTimeout(() => swapTurns(), 500);
                }
            }

            function activateSwap(player, skillId) {
                 if (!isGameActive || playerSkillsUsed[player === X_CLASS ? 'x' : 'o'].includes(skillId) || targetingState) return;
                 if (handleMirrorReflection(player, skillId)) return;

                 targetingState = { skill: 'swap', player: player, step: 1, firstCell: null };
                 boardElement.classList.add('targeting', 'targeting-swap');
                 logAction("Selecione a primeira peça para trocar.", "system-log");
                 updateSkillButtonsState();
            }

            function handleSwapExecution(cell1, cell2) {
                const player = targetingState.player;
                
                const class1 = cell1.classList.contains(X_CLASS) ? X_CLASS : O_CLASS;
                const class2 = cell2.classList.contains(X_CLASS) ? X_CLASS : O_CLASS;

                cell1.classList.remove(class1); cell1.classList.add(class2);
                cell2.classList.remove(class2); cell2.classList.add(class1);

                const moves1 = class1 === X_CLASS ? movesX : movesO;
                const moves2 = class2 === X_CLASS ? movesX : movesO;
                
                const index1 = moves1.indexOf(cell1);
                const index2 = moves2.indexOf(cell2);

                if (class1 === class2) {
                    if(index1 > -1) moves1[index1] = cell2;
                    if(index2 > -1) moves1[index2] = cell1;
                } else {
                    if (index1 > -1) moves1.splice(index1, 1, cell2);
                    if (index2 > -1) moves2.splice(index2, 1, cell1);
                }
                
                if (class1 !== class2) swappedOwnWithEnemy = true;
                
                logAction(`${player === X_CLASS ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText} usa Troca 🔁!`, `player-${player}-log`);
                playSound(teleportSound);
                playerSkillsUsed[player].push('swap');
                
                resetTargetingMode();
                
                const winX = checkWin(X_CLASS, movesX);
                const winO = checkWin(O_CLASS, movesO);

                if(winX.hasWon) {
                    handleDamage(X_CLASS, DAMAGE_PER_POINT, winX.combo);
                } else if (winO.hasWon) {
                    handleDamage(O_CLASS, DAMAGE_PER_POINT, winO.combo);
                } else {
                     if (player === X_CLASS) {
                          swapTurns();
                     } else {
                          setTimeout(() => swapTurns(), 500);
                     }
                }
            }
             
            function activateShove(player, skillId){ 
                if (!isGameActive || playerSkillsUsed[player === X_CLASS ? 'x' : 'o'].includes(skillId) || targetingState) return;
                if (handleMirrorReflection(player, skillId)) return;

                targetingState = { skill: 'shove', player: player, step: 1, pieceToMove: null };
                boardElement.classList.add('targeting', 'targeting-shove');
                logAction("Selecione uma peça (sua ou inimiga) para empurrar.", "system-log");
                updateSkillButtonsState();
            }

            function updateShoveTargets(originCell, clearOldOrigin = false) {
                if(clearOldOrigin && targetingState.pieceToMove) {
                    targetingState.pieceToMove.classList.remove('shove-origin');
                }
                cellElements.forEach(c => c.classList.remove('targetable'));
                originCell.classList.add('shove-origin');
                const adjacent = getAdjacentCells(parseInt(originCell.dataset.cellIndex));
                adjacent.forEach(cell => {
                    if (!cell.classList.contains(X_CLASS) && !cell.classList.contains(O_CLASS)) {
                        cell.classList.add('targetable');
                    }
                });
            }

            function handleShoveExecution(originCell, destinationCell) {
                const player = targetingState.player;
                const pieceClass = originCell.classList.contains(X_CLASS) ? X_CLASS : O_CLASS;
                
                originCell.classList.remove(pieceClass);
                destinationCell.classList.add(pieceClass);

                const moves = pieceClass === X_CLASS ? movesX : movesO;
                const moveIndex = moves.indexOf(originCell);
                if (moveIndex > -1) {
                    moves[moveIndex] = destinationCell;
                }

                logAction(`${player === X_CLASS ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText} usa Empurrão 🖐️!`, `player-${player}-log`);
                playSound(teleportSound);
                playerSkillsUsed[player].push('shove');
                
                resetTargetingMode();

                const winResult = checkWin(pieceClass, moves);
                if (winResult.hasWon) {
                    handleDamage(pieceClass, DAMAGE_PER_POINT, winResult.combo);
                } else {
                    if (player === X_CLASS) {
                        swapTurns();
                    } else {
                        setTimeout(() => swapTurns(), 500);
                    }
                }
            }

             function activateMirror(player, skillId){
                 if (!isGameActive) return;
                 const playerSkills = player === X_CLASS ? skills.x : skills.o;
                 if(playerSkills.mirrorActive || playerSkillsUsed[player === X_CLASS ? 'x' : 'o'].includes(skillId)) return;
                 if (handleMirrorReflection(player, skillId)) return;

                 playerSkills.mirrorActive = true;
                 playerSkillsUsed[player === X_CLASS ? 'x' : 'o'].push(skillId);

                 const charElement = player === X_CLASS ? charX : charO;
                 charElement.classList.add('mirror-active');
                 logAction(`${player === X_CLASS ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText} ativa o Espelho 🪞.`, `player-${player}-log`);
                 playSound(shieldSound);
                 updateSkillButtonsState();

                 if(player === O_CLASS){
                      setTimeout(() => swapTurns(), 500);
                 } else {
                    swapTurns();
                 }
             }
             
             function handleMirrorReflection(player, skillId) {
                 const opponent = player === X_CLASS ? 'o' : 'x';
                 if (skills[opponent].mirrorActive) {
                      logAction(`Espelho 🪞 de ${opponent.toUpperCase()} reflete a habilidade ${ALL_SKILLS[skillId].icon}!`, `player-${opponent}-log`);
                      skills[opponent].mirrorActive = false;
                      const opponentChar = opponent === X_CLASS ? charX : charO;
                      opponentChar.classList.remove('mirror-active');
                      playSound(shieldSound);
                      
                      // Skill was used up by the reflection attempt
                      playerSkillsUsed[player].push(skillId);
                      
                      updateSkillButtonsState();

                      // The mirrored action counts as the original user's turn
                      setTimeout(() => swapTurns(), 500); 

                      return true;
                 }
                 return false;
             }

             function resetTargetingMode() {
                 if (targetingState) {
                     if (targetingState.firstCell) targetingState.firstCell.classList.remove('swap-first-pick');
                     if (targetingState.pieceToMove) targetingState.pieceToMove.classList.remove('shove-origin');
                 }
                 targetingState = null;
                 boardElement.className = 'board'; // Reset all targeting classes
                 cellElements.forEach(c => c.classList.remove('targetable'));
                 updateSkillButtonsState();
             }

             function drawWinningLaserLine(winnerClass, combo) { 
                 /* Full original logic here, no changes needed */ 
                 const startCell = cellElements[combo[0]];
                 const endCell = cellElements[combo[2]];
                 const boardRect = boardElement.getBoundingClientRect();
                 const startRect = startCell.getBoundingClientRect();
                 const endRect = endCell.getBoundingClientRect();

                 const startX = startRect.left + startRect.width / 2 - boardRect.left;
                 const startY = startRect.top + startRect.height / 2 - boardRect.top;
                 const endX = endRect.left + endRect.width / 2 - boardRect.left;
                 const endY = endRect.top + endRect.height / 2 - boardRect.top;

                 const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
                 const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));

                 winningLaserLine.style.setProperty('--laser-color', winnerClass === X_CLASS ? 'var(--cor-x)' : 'var(--cor-o)');
                 winningLaserLine.style.width = `${length}px`;
                 winningLaserLine.style.height = '10px';
                 winningLaserLine.style.top = `${startY - 5}px`;
                 winningLaserLine.style.left = `${startX}px`;
                 winningLaserLine.style.transformOrigin = '0 50%';
                 winningLaserLine.style.transform = `rotate(${angle}deg)`;

                 // Animate winning cells
                 const pulseColor = winnerClass === X_CLASS ? 'var(--cor-x)' : 'var(--cor-o)';
                 combo.forEach(index => {
                     cellElements[index].style.setProperty('--pulse-color', pulseColor);
                     cellElements[index].classList.add('winning-cell-pulse');
                 });

                 // Animate laser
                 winningLaserLine.style.animation = 'none';
                 void winningLaserLine.offsetWidth; // Trigger reflow
                 winningLaserLine.style.animation = `draw-laser-horizontal 1s ease-out forwards`; // a generic animation for length
                 winningLaserLine.classList.add('winning-laser-active');
             }

            function updateSkillButtonsState(){
                if (!skills) return;
                const isPlayerTurn = !isOTurn;
                
                const updateButtonsForPlayer = (player, container) => {
                    container.querySelectorAll('.skill-button').forEach(button => {
                        if(button.id.includes('indicator')) return; // Skip passive indicators

                        const skillId = button.id.replace(`-${player}`, '');
                        const skill = ALL_SKILLS[skillId];
                        let canUse = (player === X_CLASS ? isPlayerTurn : !isOTurn) && !targetingState;
                        
                        if (playerSkillsUsed[player].includes(skillId) && skill.type === 'active') {
                             canUse = false; // Skill already used
                        }
                        
                        // Specific conditions
                        if (skillId === 'shield' && skills[player].shieldActive) canUse = false;
                        if (skillId === 'mirror' && skills[player].mirrorActive) canUse = false;
                        
                        const currentHealth = player === X_CLASS ? healthX : healthO;
                        let maxHealth = 100;
                        if (gameMode === 'campaign' && currentLevelData?.customInitialHealth) {
                            maxHealth = player === X_CLASS ? (currentLevelData.customInitialHealth.x || 100) : (currentLevelData.customInitialHealth.o || 100);
                        }
                        if (skillId === 'heal' && currentHealth >= maxHealth) canUse = false;


                        const currentMoves = player === X_CLASS ? movesX : movesO;
                        if (skillId === 'sacrifice' && currentMoves.length === 0) canUse = false;
                        if (skillId === 'swap' && (movesX.length + movesO.length < 2)) canUse = false;
                        if (skillId === 'shove' && (movesX.length + movesO.length < 1)) canUse = false;

                        // Player can only interact with their own buttons
                        button.disabled = (player === O_CLASS) || !canUse;
                    });
                };
                
                updateButtonsForPlayer('x', skillsXContainer);
                updateButtonsForPlayer('o', skillsOContainer);
            }

            function updateOldestPieceIndicator(){
                cellElements.forEach(cell => cell.classList.remove('oldest-piece'));
                if (movesX.length === MAX_MOVES) movesX[0].classList.add('oldest-piece');
                if (movesO.length === MAX_MOVES) movesO[0].classList.add('oldest-piece');
            }
            function applyAvatar(element, avatar){
                if (!element) return;
                element.innerHTML = '';
                element.style.backgroundImage = '';
                element.style.backgroundColor = 'transparent';
                element.style.borderStyle = avatar.type === 'image' ? 'none' : 'dashed';
                if (avatar.type === 'emoji') {
                    element.innerText = avatar.value;
                } else if (avatar.type === 'image') {
                    element.style.backgroundImage = `url('${avatar.value}')`;
                }
            }
            
            function openCharacterModal(player) {
                playerToEdit = player;
                modal.classList.add('show');
            }

            presetCharsContainer.innerHTML = '';
            PRESET_EMOJIS.forEach(emoji => {
                const charDiv = document.createElement('div');
                charDiv.classList.add('preset-char');
                charDiv.innerText = emoji;
                charDiv.addEventListener('click', () => {
                    const avatar = { type: 'emoji', value: emoji };
                    if (playerToEdit === 'x_arsenal') {
                        playerXAvatar = avatar;
                        applyAvatar(arsenalCharPreview, avatar);
                    } else if (playerToEdit === 'o') {
                        playerOAvatar = avatar;
                        applyAvatar(charPreviewO, avatar);
                    }
                    modal.classList.remove('show');
                });
                presetCharsContainer.appendChild(charDiv);
            });
            
            // --- GLOBAL EVENT LISTENERS ---
            notificationCloseButton.addEventListener('click', () => notificationModal.classList.remove('show'));
            saveArsenalButton.addEventListener('click', saveArsenalAndProceed);
            arsenalPlayerNameInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') saveArsenalAndProceed(); });
            arsenalCharPreview.addEventListener('click', () => openCharacterModal('x_arsenal'));
            charPreviewO.addEventListener('click', () => openCharacterModal('o'));
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('show'); });
            changeArsenalButton.addEventListener('click', () => { 
                populateArsenalScreen();
                showScreen(arsenalScreen, 'back'); 
            });
            
            campaignButton.addEventListener('click', showCampaignMap);
            backToMenuFromCampaignButton.addEventListener('click', () => showScreen(modeSelectMenu, 'back'));
            
            singlePlayerButton.addEventListener('click', () => { gameMode = 'single'; showScreen(difficultySelectMenu, 'forward'); });
            localMultiplayerButton.addEventListener('click', () => { gameMode = 'local'; showScreen(playerSetupMenu, 'forward'); });
            taticoModeButton.addEventListener('click', () => { showScreen(taticoSubmenu, 'forward'); });
            taticoSubmenuButtons.forEach(button => { button.addEventListener('click', () => { selectedSubMode = button.dataset.submode; opponentSelectTitle.innerText = `Modo ${selectedSubMode === 'tatico' ? 'Batalha Tática' : 'Arena Caótica'}`; showScreen(opponentSelectMenu, 'forward'); }); });
            opponentHumanButton.addEventListener('click', () => { gameMode = selectedSubMode; showScreen(playerSetupMenu, 'forward'); });
            opponentAiButton.addEventListener('click', () => { gameMode = selectedSubMode + '_single'; showScreen(difficultySelectMenu, 'forward'); });
            difficultyButtons.forEach(button => { button.addEventListener('click', () => { aiDifficulty = button.dataset.difficulty; initializeMatch(); showScreen(gameScreen, 'forward'); }); });
            backToModeSelectBtn.addEventListener('click', () => showScreen(modeSelectMenu, 'back'));
            backToModeSelectBtn2.addEventListener('click', () => { const targetScreen = (gameMode === 'single') ? modeSelectMenu : opponentSelectMenu; showScreen(targetScreen, 'back'); });
            backToModeSelectBtn3.addEventListener('click', () => showScreen(modeSelectMenu, 'back'));
            backToTaticoMenuBtn.addEventListener('click', () => showScreen(taticoSubmenu, 'back'));
            startGameButton.addEventListener('click', () => { initializeMatch(); showScreen(gameScreen, 'forward'); });

            historyToggleButton.addEventListener('click', () => historyPanel.classList.toggle('show'));

            restartButton.addEventListener('click', () => {
                if (gameMode === 'campaign') {
                    showCampaignMap();
                } else {
                    showScreen(modeSelectMenu, 'back');
                }
            });

            // --- GAME INITIALIZATION ---
            document.addEventListener('DOMContentLoaded', loadData);
        </script>
    </body>
</html>
