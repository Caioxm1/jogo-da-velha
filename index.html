<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo da Velha - Batalha na Arena</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --cor-fundo: #1a2a33;
            --cor-tabuleiro: #1f3641;
            --cor-celula: #a8bfc9;
            --cor-celula-hover: #dbe8ef;
            --cor-x: #31c3bd;
            --cor-o: #f2b137;
            --cor-texto: #ffffff;
            --sombra: 0 8px 16px rgba(0, 0, 0, 0.25);
            --vida-cor: #2ecc71;
            --vida-fundo: #4a5a63;
            --dano-cor: #e74c3c;
            --escudo-cor: #3498db;
            --espelho-cor: #9b59b6;
            --interdicao-cor: #e74c3c;
            --amaldicoado-cor: #8e44ad;
            --font-principal: 'Poppins', sans-serif;
            --font-titulo: 'Bangers', cursive;
        }

        *, *::after, *::before {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Evita rolagem na p√°gina principal */
        }

        body {
            font-family: var(--font-principal);
            color: var(--cor-texto);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px; /* Reduz o padding para aproveitar a tela */
            background: linear-gradient(-45deg, #10212b, #1a2a33, #1f3641, #31c3bd);
            background-size: 400% 400%;
            animation: animated-background 20s ease infinite;
        }

        #game-container {
            text-align: center;
            width: 100%;
            max-width: 450px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        .screen {
            width: 100%;
            height: 100%; /* Faz a tela ocupar todo o cont√™iner */
            position: absolute;
            top: 0;
            left: 0;
            background-color: transparent;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Centraliza o conte√∫do da tela */
        }

        .screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--cor-fundo);
            z-index: -1;
            border-radius: 20px;
            opacity: 0.9;
        }

        .screen.active {
            visibility: visible;
            opacity: 1;
            z-index: 10;
        }
        
        /* Ajustes na tela do jogo para melhor distribui√ß√£o vertical */
        #game-screen {
            justify-content: space-around; /* Distribui os elementos */
        }

        h1, h2, h3 {
            font-family: var(--font-titulo);
            font-weight: 400;
            letter-spacing: 1px;
        }
        
        h1 {
            font-size: clamp(2.5rem, 10vw, 3.5rem); /* Aumenta a responsividade da fonte */
            margin-bottom: 1rem;
            color: var(--cor-celula);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        h2 {
            font-size: clamp(1.2rem, 6vw, 1.5rem);
            margin-bottom: 1rem;
            color: var(--cor-celula-hover);
        }
        
        h3 {
            font-size: clamp(1rem, 5vw, 1.2rem);
            margin-bottom: 0.5rem;
            color: var(--cor-o);
        }

        .menu-button {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding: clamp(0.8rem, 4vw, 1.2rem); /* Padding adapt√°vel */
            font-size: clamp(1rem, 4.5vw, 1.2rem);
            font-weight: 700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            color: var(--cor-tabuleiro);
            background-color: var(--cor-celula);
            box-shadow: inset 0 -4px 0 #899ba5;
            transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.2s;
            margin-top: 1rem;
        }

        .menu-button:disabled {
            background-color: var(--vida-fundo);
            box-shadow: inset 0 -4px 0 #3a4952;
            cursor: not-allowed;
            color: #7b8c96;
        }

        .menu-button:active:not(:disabled) {
            transform: translateY(2px) scale(0.98);
            box-shadow: inset 0 -2px 0 #899ba5;
        }

        .menu-button.secondary {
            background-color: var(--cor-tabuleiro);
            color: var(--cor-celula);
            box-shadow: inset 0 -4px 0 #10212b;
        }

        .menu-button.tatico {
            background-color: var(--cor-o);
            color: var(--cor-fundo);
            box-shadow: inset 0 -4px 0 #b48328;
        }

        #save-profile-button {
            animation: pulse-active-player 2.5s infinite;
        }

        .menu-button.animated-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -150%;
            width: 75%;
            height: 100%;
            background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.4) 50%, rgba(255, 255, 255, 0) 100%);
            transform: skewX(-25deg);
            animation: shine-sweep 4s infinite;
            animation-delay: var(--delay, 0s);
        }

        /* --- ARSENAL SCREEN STYLES --- */
        #arsenal-screen .profile-container {
            background-color: var(--cor-tabuleiro);
            padding: 1.5rem;
            border-radius: 15px;
            margin-bottom: 1.5rem;
            box-shadow: var(--sombra);
        }
        
        .arsenal-layout {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .skill-selection-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        @media (min-width: 768px) {
            #game-container { max-width: 800px; }
            .arsenal-layout { flex-direction: row; }
            .profile-container { flex: 1; }
            .skill-selection-container { flex: 2; }
        }

        #skill-deck-container, #player-kit-container {
            background-color: var(--cor-tabuleiro);
            padding: 1rem;
            border-radius: 15px;
        }

        .skill-deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 0.5rem; /* Este gap baixo √© bom para o arsenal, mas ruim para a campanha */
        }

        .player-kit-slots {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            background-color: var(--cor-fundo);
            border-radius: 10px;
        }
        
        .kit-slot {
            width: 70px;
            height: 95px;
            border: 2px dashed var(--cor-celula);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: var(--cor-celula);
        }
        
        .skill-card {
            background-color: var(--cor-fundo);
            border: 2px solid var(--cor-celula);
            border-radius: 10px;
            padding: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1.3;
            min-height: 95px;
        }
        
        .skill-card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px var(--cor-celula-hover);
        }

        .skill-card.selected {
            border-color: var(--cor-o);
            box-shadow: 0 0 15px var(--cor-o);
            background-color: #2f4858;
        }
        
        .skill-card .skill-icon {
            font-size: 2rem;
            line-height: 1;
        }

        .skill-card .skill-name {
            font-size: 0.7rem;
            font-weight: 600;
            margin-top: 0.5rem;
            text-align: center;
        }
        
        .player-input-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            width: 100%;
            margin-top: 1rem;
        }

        .char-preview {
            width: 70px; height: 70px;
            cursor: pointer;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            transition: transform 0.2s, filter 0.2s;
            flex-shrink: 0;
            border: 2px dashed var(--cor-celula);
            border-radius: 10px;
        }
        .char-preview:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 0 8px var(--color, var(--cor-celula)));
        }

        #char-preview-x { --color: var(--cor-x); }
        #char-preview-o { --color: var(--cor-o); }

        .player-name-input {
            flex-grow: 1;
            padding: 0.8rem;
            border-radius: 8px;
            border: 2px solid var(--cor-celula);
            background-color: var(--cor-fundo);
            color: white;
            font-size: 1rem;
            font-family: var(--font-principal);
            width: 100%;
        }
        .player-name-input:focus {
            outline: none;
            border-color: var(--color);
            --color: var(--cor-x);
        }
        
        /* --- Health, Skills, Board etc --- */
        .health-bars {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .health-container {
            width: 48%; padding: 5px;
            border-radius: 12px;
            transition: box-shadow 0.3s ease, transform 0.3s ease;
        }

        .health-container.active {
            animation: pulse-active-player-enhanced 2s infinite ease-in-out;
        }

        .player-label {
            font-weight: 600;
            font-size: clamp(0.8rem, 3.5vw, 1rem); /* Fonte adapt√°vel */
            margin-bottom: 0.5rem;
            white-space: nowrap; /* Evita que o nome quebre a linha */
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-label.player-x { color: var(--cor-x); }
        .player-label.player-o { color: var(--cor-o); }

        .health-bar-background {
            width: 100%; height: 18px;
            background-color: var(--vida-fundo);
            border-radius: 10px; overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.3s;
        }

        .health-bar-background.damage {
            animation: health-bar-damage 0.5s ease-in-out;
        }

        .health-bar-foreground {
            height: 100%; width: 100%;
            background-color: var(--vida-cor);
            border-radius: 10px;
            transition: width 0.5s ease-in-out;
        }

        .skills-container {
            display: none;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding: 0 5%; /* Adiciona padding lateral */
        }
        .skills-container.show {
            display: flex;
        }
        .skill-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .skill-button {
            background: var(--cor-tabuleiro);
            border: 2px solid var(--cor-celula);
            color: white;
            font-size: 1.5rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }
        .skill-button:hover:not(:disabled) {
            transform: scale(1.1);
            background-color: var(--cor-celula-hover);
            color: var(--cor-fundo);
        }
        .skill-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            background-color: var(--vida-fundo);
        }

        .battle-arena {
            height: 80px; background-color: var(--cor-tabuleiro);
            margin-bottom: 1rem; border-radius: 10px;
            display: flex; justify-content: space-between;
            align-items: center; padding: 0 20px;
            position: relative; overflow: hidden;
        }

        .character {
            width: 60px; height: 60px;
            position: relative;
            transition: transform 0.3s ease, background-color 0.3s, box-shadow 0.3s, opacity 0.4s, filter 0.4s;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            display: flex; justify-content: center;
            align-items: center; font-size: 30px;
            line-height: 1;
        }

        .character.turn-active::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 130%;
            height: 130%;
            background: radial-gradient(circle, var(--player-color) 20%, transparent 65%);
            border-radius: 50%;
            z-index: -1;
            animation: aura-glow 2.5s infinite ease-in-out;
        }

        .character.shielded {
            animation: pulse-shield 1.5s infinite;
        }
        
        .character.damage-boost {
            animation: pulse-damage-boost 1.5s infinite;
        }

        .character.mirror-active {
            animation: pulse-mirror 1.5s infinite;
        }

        .character.attack { animation: energetic-attack 0.6s ease-in-out; }
        .character.hit { animation: heavy-hit 0.6s ease-in-out; }
        .character.victory { animation: victory-pose 2s forwards; }
        .character.defeat { animation: defeat-pose 1.5s forwards; }

        .board {
            display: grid; 
            grid-template-columns: repeat(3, 1fr);
            gap: 10px; /* Reduz o gap para telas menores */
            width: 100%; 
            max-width: 400px; /* Limita o tamanho m√°ximo para n√£o ficar enorme */
            aspect-ratio: 1 / 1;
            margin: 0 auto; 
            background-color: var(--cor-tabuleiro);
            border-radius: 15px; 
            padding: 10px; 
            box-shadow: var(--sombra);
            pointer-events: auto;
            position: relative; 
        }

        .board.locked {
            pointer-events: none;
        }

        .board.targeting .cell {
            cursor: not-allowed;
            opacity: 0.6;
            pointer-events: none;
        }
        
        .board.targeting .cell.targetable {
            cursor: crosshair;
            animation: pulse-target 1s infinite;
            opacity: 1;
            pointer-events: auto;
        }
        
        .board.targeting-sacrifice.targeting .cell.x,
        .board.targeting-sacrifice.targeting .cell.o {
            cursor: not-allowed; opacity: 0.6; pointer-events: none;
        }

        .board.targeting-sacrifice.targeting.is-x-turn .cell.x,
        .board.targeting-sacrifice.targeting.is-o-turn .cell.o {
            cursor: crosshair !important;
            animation: pulse-target 1s infinite !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        .board.targeting-swap.targeting .cell:not(.x):not(.o),
        .board.targeting-shove.targeting .cell.x,
        .board.targeting-shove.targeting .cell.o {
            cursor: not-allowed; opacity: 0.6; pointer-events: none;
        }
        .board.targeting-swap.targeting .cell.x,
        .board.targeting-swap.targeting .cell.o,
        .board.targeting-shove.targeting .cell.targetable,
        .board.targeting-shove.targeting .cell.shove-origin {
            cursor: crosshair;
            opacity: 1;
            pointer-events: auto;
        }
        
        .board.targeting .cell.swap-first-pick,
        .board.targeting .cell.shove-origin {
            animation: pulse-shield 1s infinite;
            opacity: 1;
        }
        
        .board.targeting-shove.targeting .cell:not(.targetable):not(.shove-origin) {
            cursor: not-allowed; opacity: 0.6; pointer-events: none;
        }

        .board.dimmed-board::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 15px; 
            z-index: 9; 
            opacity: 0; 
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
        }
        
        .board.dimmed-board.dimmed-board::after {
            opacity: 1;
            visibility: visible;
        }

        .cell {
            background-color: var(--cor-celula);
            border-radius: 10px; cursor: pointer;
            position: relative; box-shadow: inset 0 -4px 0 #899ba5;
            transition: transform 0.2s, background-color 0.2s, opacity 0.3s, box-shadow 0.3s;
            overflow: hidden; 
        }

        .cell:not(.x):not(.o):not(:disabled):hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4), inset 0 -4px 0 #899ba5;
        }

        .cell.oldest-piece {
            animation: fade-out-pulse 2s infinite ease-in-out;
        }

        .cell.interdicted {
            cursor: not-allowed !important;
            background-color: #556672 !important;
            animation: shake 0.5s;
        }

        .cell.interdicted::after {
            content: 'üö´';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: var(--interdicao-cor);
            opacity: 0.8;
        }

        .cell.cursed {
            box-shadow: 0 0 10px 5px var(--amaldicoado-cor);
            animation: pulse-cursed 1s infinite;
        }

        .cell.mined::after {
            content: 'üí•'; 
            position: absolute;
            font-size: 1.2rem;
            bottom: 5px;
            left: 5px;
            opacity: 0.9;
        }
        
        .cell.portal {
            box-shadow: 0 0 15px 5px var(--espelho-cor);
            animation: pulse-portal 1.5s infinite;
        }
        
        .cell.x, .cell.o { cursor: not-allowed; }

        @keyframes place-mark-pop-in {
            0% { transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(0.5); opacity: 0; }
            80% { transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(1); opacity: 1; }
        }

        .cell.x::before, .cell.x::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 12%; /* Deixa o X um pouco mais grosso */
            background-color: var(--cor-x);
            border-radius: 5px;
            transform-origin: center;
            animation: place-mark-pop-in 0.3s ease-out forwards;
            pointer-events: none;
        }
        .cell.x::before {
            --rotation: 45deg;
            transform: translate(-50%, -50%) rotate(var(--rotation));
        }
        .cell.x::after {
            --rotation: -45deg;
            transform: translate(-50%, -50%) rotate(var(--rotation));
        }

        .cell.o::before {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 65%; height: 65%; background-color: transparent;
            border: 10px solid var(--cor-o); /* Borda mais fina para telas pequenas */
            border-radius: 50%;
            animation: place-mark-pop-in 0.3s ease-out forwards;
            pointer-events: none;
        }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 1rem;
        }
        .modal-overlay.show {
            display: flex;
        }

        .modal-content, .winning-message-content {
            background-color: var(--cor-tabuleiro);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: var(--sombra);
            color: white;
            text-align: center;
            width: 100%;
            max-width: 400px;
        }

        .modal-content h2 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .character-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .preset-char {
            font-size: 2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .preset-char:hover {
            transform: scale(1.2);
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .modal-upload-button {
            display: inline-block;
            font-size: 1rem;
            font-weight: 600;
            background-color: var(--cor-celula);
            color: var(--cor-tabuleiro);
            border: none;
            border-radius: 10px;
            padding: 0.8rem 1.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .modal-upload-button:hover {
            background-color: #fff;
        }

        .winning-message-content {
            font-family: var(--font-titulo);
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 400;
        }
        
        .winning-message-content button {
            font-family: var(--font-principal);
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            font-weight: 600;
            background-color: var(--cor-celula);
            color: var(--cor-tabuleiro);
            border: none;
            border-radius: 10px;
            padding: 1rem 2rem;
            cursor: pointer;
            margin-top: 2rem;
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .winning-message-content button:hover {
            transform: scale(1.05);
            background-color: #fff;
        }

        .turn-announcement-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 85%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
        }
        
        .turn-announcement-container.show {
            animation: fade-in-out 2s ease-in-out forwards;
        }
        
        .turn-announcement-text {
            font-family: var(--font-titulo);
            font-size: clamp(1.8rem, 8vw, 2.5rem);
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            padding: 1rem 2rem;
            background-color: rgba(26, 42, 51, 0.7);
            border-radius: 15px;
            backdrop-filter: blur(4px);
        }

        /* --- ESTILOS DO HIST√ìRICO E PAUSE --- */
        #history-toggle-button {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 20; /* Fica acima do painel e da tela de jogo */
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            border-radius: 50%;
            background-color: var(--cor-tabuleiro);
            color: var(--cor-celula);
            border: 2px solid var(--cor-celula);
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            display: none; /* Come√ßa escondido, aparece s√≥ na tela de jogo */
        }

        #history-toggle-button.visible {
            display: block;
        }

        #history-toggle-button:hover {
            transform: scale(1.1);
            background-color: var(--cor-celula-hover);
            color: var(--cor-fundo);
        }

        /* --- ESTILOS DO BOT√ÉO E MENU DE PAUSE --- */
        #pause-button {
            position: absolute;
            top: 15px;
            left: 15px; /* Colocado no canto superior esquerdo */
            z-index: 20;
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            border-radius: 50%;
            background-color: var(--cor-tabuleiro);
            color: var(--cor-celula);
            border: 2px solid var(--cor-celula);
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            display: none; /* Come√ßa escondido */
        }

        #pause-button.visible {
            display: block;
        }

        #pause-button:hover {
            transform: scale(1.1);
            background-color: var(--cor-celula-hover);
            color: var(--cor-fundo);
        }

        #pause-modal .modal-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        #history-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 250px; /* Largura do painel */
            height: 100%;
            background-color: rgba(31, 54, 65, 0.85); /* Fundo com 85% de opacidade */
            backdrop-filter: blur(8px); /* Efeito de vidro fosco */
            border-left: 2px solid var(--cor-o);
            box-shadow: -5px 0 25px rgba(0,0,0,0.5);
            z-index: 19;
            padding: 1rem;
            padding-top: 70px; /* Espa√ßo para o bot√£o n√£o sobrepor o texto */
            transform: translateX(100%); /* Come√ßa escondido fora da tela √† direita */
            transition: transform 0.4s ease-in-out;
            pointer-events: none; /* N√£o interage enquanto escondido */
        }

        #history-panel.show {
            transform: translateX(0); /* Fica vis√≠vel na tela */
            pointer-events: auto; /* Pode ser interagido */
        }

        #history-log-content {
            height: 100%;
            overflow-y: auto; /* Adiciona scroll se o conte√∫do for maior que o painel */
            display: flex;
            flex-direction: column-reverse; /* Mensagens novas aparecem em cima */
        }

        .log-entry {
            padding: 0.5rem;
            border-bottom: 1px solid var(--cor-fundo);
            font-size: 0.9rem;
            animation: fade-in-entry 0.5s ease;
            text-align: left;
            word-wrap: break-word;
        }

        /* Cores para os jogadores no log */
        .log-entry.player-x-log { color: var(--cor-x); }
        .log-entry.player-o-log { color: var(--cor-o); }
        .log-entry.system-log { color: var(--cor-celula-hover); font-style: italic; }

        @keyframes fade-in-entry {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Estilizando a barra de rolagem (opcional, mas elegante) */
        #history-log-content::-webkit-scrollbar { width: 5px; }
        #history-log-content::-webkit-scrollbar-track { background: transparent; }
        #history-log-content::-webkit-scrollbar-thumb { background-color: var(--cor-o); border-radius: 10px; }
        
        /* ===== AJUSTE DA TELA DE CAMPANHA (VERS√ÉO DEFINITIVA) ===== */
        #campaign-map-screen {
            justify-content: space-between; 
            gap: 1rem;
        }

        #campaign-map-screen > h1,
        #campaign-map-screen > #back-to-menu-from-campaign {
            flex-shrink: 0; /* Impede que o t√≠tulo e o bot√£o encolham */
        }
        
        #campaign-level-grid {
            flex-grow: 1; 
            min-height: 0; 
            overflow-y: auto;  
            overflow-x: hidden; 
            display: grid;
            gap: 1.2rem;  
            align-content: start; 
            padding: 1rem;
        }

        #campaign-level-grid::-webkit-scrollbar {
            width: 8px;
        }
        #campaign-level-grid::-webkit-scrollbar-track {
            background: var(--cor-fundo); 
            border-radius: 10px;
        }
        #campaign-level-grid::-webkit-scrollbar-thumb {
            background-color: var(--cor-o);
            border-radius: 10px;
            border: 2px solid var(--cor-fundo);
        }
        #campaign-level-grid::-webkit-scrollbar-thumb:hover {
            background-color: #ffca6e; 
        }

        #campaign-level-grid .menu-button {
            width: auto;
            min-width: 100px;
            aspect-ratio: 1 / 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            line-height: 1.2;
        }
        #campaign-level-grid .menu-button[disabled] {
            opacity: 0.7;
        }
        #campaign-level-grid .mission-complete {
            background-color: var(--cor-x);
            box-shadow: inset 0 -4px 0 #208985;
            color: var(--cor-fundo);
        }

        /* ===== FIM DO AJUSTE ===== */

        /* --- ESTILOS DO TEXTO FLUTUANTE DE DANO/CURA --- */
        .floating-text {
            position: absolute;
            top: 25%;
            font-family: var(--font-titulo);
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            pointer-events: none;
            animation: float-and-fade 1.5s ease-out forwards;
        }

        .floating-text.damage {
            color: var(--dano-cor);
        }
        .floating-text.heal {
            color: var(--vida-cor);
        }

        .floating-text.player-x {
            left: 25%;
            transform: translateX(-50%);
        }
        .floating-text.player-o {
            right: 25%;
            transform: translateX(50%);
        }

        @keyframes float-and-fade {
            0% {
                transform: translate(var(--translateX, -50%), 0);
                opacity: 1;
            }
            100% {
                transform: translate(var(--translateX, -50%), -60px);
                opacity: 0;
            }
        }


        @keyframes shine-sweep {
            100% { left: 150%; }
        }

        @keyframes fade-out-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes pulse-active-player-enhanced {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255,255,255,0.4);
            }
            50% {
                transform: scale(1.03);
                box-shadow: 0 0 12px 6px rgba(255,255,255,0.3);
            }
        }

        @keyframes aura-glow {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.5;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 0.8;
            }
        }

        @keyframes energetic-attack {
            0% { transform: translate(0) scale(1); filter: none; }
            40% {
                transform: translate(var(--translate-x)) scale(1.3) rotate(-5deg);
                filter: drop-shadow(0 0 15px #3498db);
            }
            60% { transform: translate(calc(var(--translate-x) * 0.8)) scale(1.1) rotate(5deg); filter: none; }
            100% { transform: translate(0) scale(1); filter: none; }
        }

        @keyframes heavy-hit {
            0% { transform: translate(0); filter: none; }
            20% {
                transform: translate(var(--translate-x)) scale(0.9);
                filter: brightness(1.5) drop-shadow(0 0 15px #e74c3c);
            }
            40% { transform: translate(calc(var(--translate-x) * -0.5)) scale(1.05); filter: none; }
            60%, 80% { transform: translate(0) rotate(-3deg); }
            70%, 90% { transform: translate(0) rotate(3deg); }
            100% { transform: translate(0) rotate(0); }
        }

        @keyframes health-bar-damage {
            from, to { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); background-color: var(--dano-cor); }
            20%, 40%, 60%, 80% { transform: translateX(4px); background-color: var(--dano-cor); }
        }

        @keyframes victory-pose {
            0% { transform: scale(1) translateY(0); filter: none; }
            50% { transform: scale(1.2) translateY(-20px); filter: drop-shadow(0 0 15px var(--winner-color)); }
            100% { transform: scale(1.2) translateY(-20px); filter: drop-shadow(0 0 15px var(--winner-color)); }
        }

        @keyframes defeat-pose {
            from { transform: rotate(0); opacity: 1; filter: none; }
            to { transform: translateY(40px) rotate(-15deg); opacity: 0.4; filter: grayscale(100%); }
        }

        @keyframes pulse-target {
            0% { background-color: #ff4757; }
            50% { background-color: var(--cor-celula); }
            100% { background-color: #ff4757; }
        }
        
        @keyframes pulse-shield {
            0% { box-shadow: 0 0 10px 3px var(--escudo-cor); }
            50% { box-shadow: 0 0 25px 8px var(--escudo-cor); }
            100% { box-shadow: 0 0 10px 3px var(--escudo-cor); }
        }
        
        @keyframes pulse-damage-boost {
            0% { box-shadow: 0 0 10px 3px var(--dano-cor); filter: saturate(1.2); }
            50% { box-shadow: 0 0 25px 8px var(--dano-cor); filter: saturate(1.8); }
            100% { box-shadow: 0 0 10px 3px var(--dano-cor); filter: saturate(1.2); }
        }

        @keyframes pulse-mirror {
            0% { box-shadow: 0 0 10px 3px var(--espelho-cor); }
            50% { box-shadow: 0 0 25px 8px var(--espelho-cor); }
            100% { box-shadow: 0 0 10px 3px var(--espelho-cor); }
        }

        @keyframes pulse-cursed {
            0% { box-shadow: 0 0 10px 3px var(--amaldicoado-cor); }
            50% { box-shadow: 0 0 25px 8px var(--amaldicoado-cor); }
            100% { box-shadow: 0 0 10px 3px var(--amaldicoado-cor); }
        }
        
        @keyframes pulse-portal {
            0% { box-shadow: 0 0 10px 3px var(--espelho-cor); }
            50% { box-shadow: 0 0 25px 8px var(--espelho-cor); }
            100% { box-shadow: 0 0 10px 3px var(--espelho-cor); }
        }
        
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        @keyframes pulse-active-player {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        @keyframes animated-background {
            0%{background-position:0% 50%}
            50%{background-position:100% 50%}
            100%{background-position:0% 50%}
        }

        .screen.slide-in-from-right { animation: slide-in-from-right 0.4s ease-out forwards; }
        @keyframes slide-in-from-right {
            from { transform: translateX(100%); opacity: 0; visibility: visible; }
            to { transform: translateX(0); opacity: 1; visibility: visible; }
        }

        .screen.slide-out-to-left { z-index: 1; animation: slide-out-to-left 0.4s ease-in forwards; }
        @keyframes slide-out-to-left {
            from { transform: translateX(0); opacity: 1; visibility: visible; }
            to { transform: translateX(-100%); opacity: 0; visibility: hidden; }
        }

        .screen.slide-in-from-left { animation: slide-in-from-left 0.4s ease-out forwards; }
        @keyframes slide-in-from-left {
            from { transform: translateX(-100%); opacity: 0; visibility: visible; }
            to { transform: translateX(0); opacity: 1; visibility: visible; }
        }

        .screen.slide-out-to-right { z-index: 1; animation: slide-out-to-right 0.4s ease-in forwards; }
        @keyframes slide-out-to-right {
            from { transform: translateX(0); opacity: 1; visibility: visible; }
            to { transform: translateX(100%); opacity: 0; visibility: hidden; }
        }
        
        @keyframes fade-in-out {
            0% { opacity: 0; transform: scale(0.7); visibility: visible; }
            20% { opacity: 1; transform: scale(1); }
            80% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.1); visibility: hidden; }
        }

        @keyframes particle-burst {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
                box-shadow: 0 0 15px 8px var(--particle-color);
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
                box-shadow: 0 0 0 0 rgba(0,0,0,0);
            }
        }

        .particle-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle at center, var(--particle-color) 0%, rgba(255,255,255,0) 70%);
            opacity: 0;
            animation: particle-burst 0.8s ease-out forwards;
            z-index: 5;
            pointer-events: none;
        }

        /* ===== CORRE√á√ÉO DEFINITIVA DO LASER ===== */
        #winning-laser-line {
            position: absolute;
            background-color: var(--laser-color, var(--interdicao-cor));
            box-shadow: 0 0 10px 5px var(--laser-color, var(--interdicao-cor)), 0 0 20px 10px rgba(255, 0, 0, 0.5);
            border-radius: 5px;
            z-index: 10;
            transform-origin: center;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            width: 0; 
            height: 0;
            pointer-events: none; /* Adicionado para garantir que n√£o interfira com cliques */
        }

        @keyframes draw-line {
            to { width: 105%; }
        }
        @keyframes draw-line-diag {
            to { width: 145%; }
        }

        #winning-laser-line.show {
            opacity: 1;
            height: 10px;
        }

        /* Linhas Horizontais */
        #winning-laser-line.line-row-0 { top: 16.66%; left: 50%; transform: translate(-50%, -50%); animation: draw-line 0.5s forwards; }
        #winning-laser-line.line-row-1 { top: 50%;   left: 50%; transform: translate(-50%, -50%); animation: draw-line 0.5s forwards; }
        #winning-laser-line.line-row-2 { top: 83.33%; left: 50%; transform: translate(-50%, -50%); animation: draw-line 0.5s forwards; }

        /* Linhas Verticais */
        #winning-laser-line.line-col-0 { top: 50%; left: 16.66%; transform: translate(-50%, -50%) rotate(90deg); animation: draw-line 0.5s forwards; }
        #winning-laser-line.line-col-1 { top: 50%; left: 50%;   transform: translate(-50%, -50%) rotate(90deg); animation: draw-line 0.5s forwards; }
        #winning-laser-line.line-col-2 { top: 50%; left: 83.33%;  transform: translate(-50%, -50%) rotate(90deg); animation: draw-line 0.5s forwards; }

        /* Linhas Diagonais */
        #winning-laser-line.line-diag-0 { top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(45deg);  animation: draw-line-diag 0.5s forwards; }
        #winning-laser-line.line-diag-1 { top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-45deg); animation: draw-line-diag 0.5s forwards; }

        .winning-laser-active {
            /* Esta classe agora √© apenas um marcador, os estilos est√£o acima */
        }
        /* ===== FIM DA CORRE√á√ÉO ===== */
        
        .cell.winning-cell-pulse {
            animation: winning-cell-pulse 1s infinite alternate;
        }
        @keyframes winning-cell-pulse {
            0% { transform: scale(1); box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
            100% { transform: scale(1.05); box-shadow: 0 0 15px var(--pulse-color); }
        }

        /* --- ESTILOS VISUAIS PARA NOVOS EVENTOS CA√ìTICOS --- */
        .cell.black-hole {
            background-color: #101518 !important;
            cursor: not-allowed !important;
            pointer-events: none;
            animation: black-hole-spin 2s linear infinite;
        }

        .cell.black-hole::before,
        .cell.black-hole::after {
            content: '‚ö´'; /* √çcone de Buraco Negro */
            font-size: 3rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 1;
            animation: none; /* Remove a anima√ß√£o de colocar X ou O */
            background-color: transparent;
            border: none;
            height: auto;
            width: auto;
        }

        @keyframes black-hole-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .cell.foggy {
            background-color: #8b9da5;
        }

        .cell.foggy::before,
        .cell.foggy::after {
            content: '‚ùì'; /* √çcone de N√©voa */
            font-size: 3rem;
            color: var(--cor-fundo);
            opacity: 1;
            transform: translate(-50%, -50%);
            animation: none;
            background-color: transparent;
            border: none;
            height: auto;
            width: auto;
        }
        
        /* Efeito para a barra de vida durante a Invers√£o de Poder */
        .health-container.power-inversion-glow {
            animation: pulse-power-inversion 1.5s infinite;
        }

        @keyframes pulse-power-inversion {
            0% { box-shadow: 0 0 8px 2px var(--espelho-cor); }
            50% { box-shadow: 0 0 20px 7px var(--espelho-cor); }
            100% { box-shadow: 0 0 8px 2px var(--espelho-cor); }
        }

        /* Regras espec√≠ficas para orienta√ß√£o retrato (celulares) */
        @media (orientation: portrait) {
            #game-container {
                justify-content: space-around; /* Distribui melhor o espa√ßo */
            }

            #game-screen {
                justify-content: space-around;
            }

            .board {
                gap: 10px;
                padding: 10px;
            }
        }

        /* --- ESTILOS DA TELA DE TUTORIAL --- */
        #tutorial-screen {
            justify-content: space-between;
        }
        .tutorial-content {
            flex-grow: 1;
            overflow-y: auto; /* Adiciona scroll se o conte√∫do for grande */
            padding: 0.5rem;
            width: 100%;
        }
        /* Estilos do Acorde√£o */
        .accordion-item {
            margin-bottom: 0.8rem;
        }
        .accordion-header {
            background-color: var(--cor-tabuleiro);
            color: var(--cor-celula-hover);
            cursor: pointer;
            padding: 1rem;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.1rem;
            font-weight: 600;
            font-family: var(--font-principal);
            border-radius: 10px;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .accordion-header::after {
            content: '‚ñº'; /* Seta para baixo */
            font-size: 1rem;
            transition: transform 0.3s ease;
        }
        .accordion-header.active::after {
            transform: rotate(180deg); /* Gira a seta */
        }
        .accordion-header:hover {
            background-color: #2f4858;
        }
        .accordion-panel {
            padding: 0 1.2rem;
            background-color: transparent;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        .accordion-panel p, .accordion-panel .skill-entry {
            color: var(--cor-celula);
            line-height: 1.6;
            margin: 1rem 0;
        }
        .accordion-panel.show {
            padding: 1rem 1.2rem;
        }
        .skill-entry {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.95rem;
        }
        .skill-entry .skill-icon {
            font-size: 1.5rem;
        }
        .skill-entry strong {
            color: var(--cor-o);
        }

        /* --- ESTILOS DO NOVO MODAL DE MISS√ÉO --- */
        .level-info-container {
            text-align: left;
            margin: 1.5rem 0;
            color: var(--cor-celula);
            line-height: 1.6;
        }

        .level-info-container h3 {
            text-align: center;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--cor-o);
        }

        .level-info-container p {
            margin-bottom: 0.5rem;
        }

        #modal-ai-skills .skill-button {
            cursor: help; /* Indica que √© apenas para visualiza√ß√£o */
            pointer-events: none; /* Impede o clique */
            transform: scale(0.9); /* Um pouco menor para diferenciar */
        }
        #modal-ai-skills .skill-button:hover {
            background-color: var(--cor-tabuleiro); /* Remove efeito hover */
        }

        #modal-special-conditions {
             display: none; 
             margin-top: 1rem; 
             padding: 0.8rem; 
             background-color: var(--cor-fundo); 
             border-radius: 8px; 
             border-left: 4px solid var(--dano-cor);
        }

        #modal-special-conditions h4 {
            margin-top: 0;
            color: var(--cor-celula-hover);
        }
    </style>
</head>
<body>
    <div id="game-container">
        
        <!-- ELEMENTOS ADICIONADOS PARA O PAUSE -->
        <button id="pause-button">‚è∏Ô∏è</button>
        <div id="pause-modal" class="modal-overlay">
            <div class="modal-content">
                <h2>Jogo Pausado</h2>
                <button id="resume-button" class="menu-button">Continuar Jogo</button>
                <button id="quit-match-button" class="menu-button secondary">Sair da Partida</button>
            </div>
        </div>
        <!-- FIM DOS ELEMENTOS DE PAUSE -->

        <button id="history-toggle-button">üìú</button>
        <div id="history-panel">
            <h3>Hist√≥rico de A√ß√µes</h3>
            <div id="history-log-content">
            </div>
        </div>

        <div id="arsenal-screen" class="screen">
            <h1>Arsenal do Jogador</h1>
            <div class="arsenal-layout">
                <div class="profile-container">
                    <h2>Seu Perfil</h2>
                    <input type="text" id="arsenal-player-name" class="player-name-input" placeholder="Digite seu nome">
                    <div class="player-input-row">
                        <div id="arsenal-char-preview" class="char-preview" title="Clique para trocar de personagem"></div>
                    </div>
                </div>

                <div class="skill-selection-container">
                    <div id="player-kit-container">
                        <h3 id="player-kit-title">Seu Kit de Batalha (Escolha 2)</h3>
                        <div class="player-kit-slots" id="player-kit-slots">
                        </div>
                    </div>
                    <div id="skill-deck-container">
                        <h2>Habilidades Desbloqueadas</h2>
                        <div class="skill-deck-grid" id="skill-deck-grid">
                        </div>
                    </div>
                </div>
            </div>
            <button class="menu-button animated-button" id="save-arsenal-button" style="--delay: 0.2s;">Salvar e Entrar na Arena</button>
        </div>

        <div id="mode-select-menu" class="screen">
            <h1>Batalha na Arena</h1>
            <button class="menu-button animated-button" id="campaign-button">Campanha: Jornada do Guerreiro</button>
            <button class="menu-button animated-button" id="single-player-button" style="--delay: 0.2s;">Partida R√°pida (vs. M√°quina)</button>
            <button class="menu-button animated-button" id="local-multiplayer-button" style="--delay: 0.4s;">Multiplayer Local</button>
            <button class="menu-button tatico animated-button" id="tatico-mode-button" style="--delay: 0.6s;">Modo T√°tico</button>
            <button class="menu-button secondary" id="change-arsenal-button" style="margin-top: 2rem;">Mudar Arsenal</button>
            <button class="menu-button secondary" id="tutorial-button">Como Jogar</button>
        </div>

        <div id="campaign-map-screen" class="screen">
            <h1>Jornada do Guerreiro</h1>
            <div id="campaign-level-grid" class="skill-deck-grid"> 
            </div>
            <button id="back-to-menu-from-campaign" class="menu-button secondary">Voltar ao Menu</button>
        </div>

        <div id="tatico-submenu" class="screen">
            <h1>Modo T√°tico</h1>
            <button class="menu-button animated-button" data-submode="tatico">Batalha T√°tica (Habilidades)</button>
            <button class="menu-button animated-button" data-submode="caotico" style="--delay: 0.2s;">Arena Ca√≥tica (Eventos)</button>
            <button id="back-to-mode-select-3" class="menu-button secondary">Voltar</button>
        </div>

        <div id="opponent-select-menu" class="screen">
            <h1 id="opponent-select-title">Escolha o Oponente</h1>
            <button class="menu-button animated-button" id="opponent-human">Jogador (Humano)</button>
            <button class="menu-button animated-button" id="opponent-ai" style="--delay: 0.2s;">M√°quina (IA)</button>
            <button id="back-to-tatico-menu" class="menu-button secondary">Voltar</button>
        </div>

        <div id="difficulty-select-menu" class="screen">
            <h1>Escolha a Dificuldade</h1>
            <button class="menu-button animated-button" data-difficulty="easy">F√°cil</button>
            <button class="menu-button animated-button" data-difficulty="normal" style="--delay: 0.2s;">Normal</button>
            <button class="menu-button animated-button" data-difficulty="hard" style="--delay: 0.4s;">Dif√≠cil</button>
            <button id="back-to-mode-select-2" class="menu-button secondary">Voltar</button>
        </div>

        <div id="player-setup-menu" class="screen">
            <h1>Configurar Oponente</h1>
            <div class="player-setup player-o">
                <h2>JOGADOR O</h2>
                <div class="player-input-row">
                    <div id="char-preview-o" class="char-preview"></div>
                    <input type="text" id="player-name-o" class="player-name-input" placeholder="Digite o nome do Jogador O" value="Jogador O">
                </div>
            </div>
            <button id="start-game-button" class="menu-button">Iniciar Batalha</button>
            <button id="back-to-mode-select" class="menu-button secondary">Voltar</button>
        </div>

        <div id="game-screen" class="screen">
            <div class="health-bars">
                <div class="health-container" id="health-container-x">
                    <div class="player-label player-x" id="game-player-label-x">JOGADOR X</div>
                    <div class="health-bar-background" id="health-bg-x">
                        <div class="health-bar-foreground" id="health-bar-x"></div>
                    </div>
                </div>
                <div class="health-container" id="health-container-o">
                    <div class="player-label player-o" id="game-player-label-o">JOGADOR O</div>
                    <div class="health-bar-background" id="health-bg-o">
                        <div class="health-bar-foreground" id="health-bar-o"></div>
                    </div>
                </div>
            </div>

            <div class="skills-container" id="skills-container">
                <div class="skill-group" id="skills-x">
                </div>
                <div class="skill-group" id="skills-o">
                </div>
            </div>

            <div class="battle-arena">
                <div class="character" id="player-x-char"></div>
                <div class="character" id="player-o-char"></div>
            </div>

            <div id="game-board" class="board"></div>
            <div id="winning-laser-line"></div>

            <div id="turn-announcement" class="turn-announcement-container">
                <div id="turn-announcement-text" class="turn-announcement-text"></div>
            </div>
        </div>

        <div id="winning-message" class="modal-overlay">
            <div class="winning-message-content">
                <div data-winning-message-text></div>
                <button id="restartButton">Continuar</button>
            </div>
        </div>
        <div id="character-select-modal" class="modal-overlay">
            <div class="modal-content">
                <h2>Escolha seu Personagem</h2>
                <div id="preset-characters" class="character-grid"></div>
                <label for="modal-upload" class="modal-upload-button">Carregar sua foto</label>
                <input type="file" id="modal-upload" class="char-upload" accept="image/*" style="display: none;">
            </div>
        </div>
        <div id="notification-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 id="notification-title">Aten√ß√£o</h2>
                <div id="notification-text" style="margin-bottom: 1.5rem; text-align: left;"></div>
                <button id="notification-close-button" class="menu-button">Entendi</button>
            </div>
        </div>
        
        <div id="level-detail-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 id="level-modal-title">N√≠vel X: Nome do Oponente</h2>
                <div class="level-info-container">
                    <p><strong>Miss√£o:</strong> <span id="modal-mission-text"></span></p>
                    <p><strong>Dificuldade:</strong> <span id="modal-difficulty-text"></span></p>
                    
                    <h3>Habilidades do Oponente:</h3>
                    <div id="modal-ai-skills" class="skill-group" style="justify-content: center; margin-bottom: 1rem;">
                    </div>

                    <div id="modal-special-conditions">
                        <h4>Condi√ß√µes Especiais:</h4>
                        <p id="modal-special-conditions-text"></p>
                    </div>
                </div>
                <button id="start-level-from-modal" class="menu-button animated-button">Iniciar Batalha</button>
                <button id="close-level-modal" class="menu-button secondary">Voltar</button>
            </div>
        </div>

        <div id="tutorial-screen" class="screen">
            <h1>Como Jogar</h1>
            <div class="tutorial-content">

                <div class="accordion-item">
                    <button class="accordion-header">O B√°sico da Arena</button>
                    <div class="accordion-panel">
                        <p><strong>Objetivo:</strong> Seu objetivo n√£o √© apenas fazer 3 em linha, mas sim <strong>zerar a barra de vida do oponente!</strong></p>
                        <p><strong>Pontuando:</strong> Cada vez que voc√™ faz uma sequ√™ncia de 3 pe√ßas (horizontal, vertical ou diagonal), voc√™ causa <strong>20 de dano</strong> ao oponente.</p>
                        <p><strong>A Regra das 3 Pe√ßas:</strong> Cada jogador pode ter no m√°ximo 3 pe√ßas no tabuleiro. Ao jogar sua 4¬™ pe√ßa, sua pe√ßa mais antiga √© removida automaticamente. Pense bem antes de jogar!</p>
                        <p><strong>Dreno de Vida:</strong> O tempo corre contra voc√™! Durante o seu turno, sua vida diminui lentamente. N√£o demore para fazer sua jogada.</p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Modos de Jogo</button>
                    <div class="accordion-panel">
                        <p><strong>Campanha:</strong> Embarque na Jornada do Guerreiro! Enfrente uma s√©rie de oponentes controlados pela IA, complete miss√µes e desbloqueie novas habilidades para seu arsenal.</p>
                        <p><strong>Partida R√°pida:</strong> Uma batalha r√°pida contra a M√°quina (IA). Escolha a dificuldade e teste suas estrat√©gias.</p>
                        <p><strong>Multiplayer Local:</strong> Desafie um amigo no mesmo dispositivo.</p>
                        <p><strong>Modo T√°tico:</strong> Onde a verdadeira estrat√©gia brilha. Use as habilidades que voc√™ selecionou no seu Arsenal para surpreender o oponente.</p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Arsenal de Habilidades</button>
                    <div class="accordion-panel" id="tutorial-skills-list">
                        </div>
                </div>

            </div>
            <button id="back-to-menu-from-tutorial" class="menu-button secondary">Voltar ao Menu</button>
        </div>


        <audio id="menu-music" src="https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/main/musicamenu.mp3" loop preload="auto"></audio>
        <audio id="battle-music" src="https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/main/musicabatalha.mp3" loop preload="auto"></audio>
        <audio id="attack-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/golpe.mp3" preload="auto"></audio>
        <audio id="hit-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/dano.mp3" preload="auto"></audio>
        <audio id="victory-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/vitoria.mp3" preload="auto"></audio>
        <audio id="shield-sound" src="https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/raw/main/prote%C3%A7ao.mp3" preload="auto"></audio>
        <audio id="bomb-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/explos%C3%A3o.mp3" preload="auto"></audio>
        <audio id="click-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/11L-bubble_bursting-1750158387072.mp3" preload="auto"></audio>
        <audio id="teleport-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/teleporte.mp3" preload="auto"></audio>
        <audio id="heal-sound" src="https://github.com/Caioxm1/jogo-da-velha/raw/main/cura.mp3" preload="auto"></audio>

        <script>
            // --- ELEMENT MAPPING ---
            const arsenalScreen = document.getElementById('arsenal-screen');
            const arsenalPlayerNameInput = document.getElementById('arsenal-player-name');
            const arsenalCharPreview = document.getElementById('arsenal-char-preview');
            const saveArsenalButton = document.getElementById('save-arsenal-button');
            const skillDeckGrid = document.getElementById('skill-deck-grid');
            const playerKitSlots = document.getElementById('player-kit-slots');
            const playerKitTitle = document.getElementById('player-kit-title');
            const changeArsenalButton = document.getElementById('change-arsenal-button');
            const modeSelectMenu = document.getElementById('mode-select-menu');
            const taticoSubmenu = document.getElementById('tatico-submenu');
            const opponentSelectMenu = document.getElementById('opponent-select-menu');
            const difficultySelectMenu = document.getElementById('difficulty-select-menu');
            const playerSetupMenu = document.getElementById('player-setup-menu');
            const gameScreen = document.getElementById('game-screen');
            const singlePlayerButton = document.getElementById('single-player-button');
            const localMultiplayerButton = document.getElementById('local-multiplayer-button');
            const taticoModeButton = document.getElementById('tatico-mode-button');
            const taticoSubmenuButtons = document.querySelectorAll('#tatico-submenu [data-submode]');
            const opponentHumanButton = document.getElementById('opponent-human');
            const opponentAiButton = document.getElementById('opponent-ai');
            const difficultyButtons = document.querySelectorAll('[data-difficulty]');
            const backToModeSelectBtn = document.getElementById('back-to-mode-select');
            const backToModeSelectBtn2 = document.getElementById('back-to-mode-select-2');
            const backToModeSelectBtn3 = document.getElementById('back-to-mode-select-3');
            const backToTaticoMenuBtn = document.getElementById('back-to-tatico-menu');
            const opponentSelectTitle = document.getElementById('opponent-select-title');
            const startGameButton = document.getElementById('start-game-button');
            const charPreviewO = document.getElementById('char-preview-o');
            const playerNameOInput = document.getElementById('player-name-o');
            const gamePlayerLabelX = document.getElementById('game-player-label-x');
            const gamePlayerLabelO = document.getElementById('game-player-label-o');
            const boardElement = document.getElementById('game-board');
            const restartButton = document.getElementById('restartButton');
            const winningMessageElement = document.getElementById('winning-message');
            const winningMessageTextElement = document.querySelector('[data-winning-message-text]');
            const healthBarX = document.getElementById('health-bar-x');
            const healthBarO = document.getElementById('health-bar-o');
            const healthBgX = document.getElementById('health-bg-x');
            const healthBgO = document.getElementById('health-bg-o');
            const healthContainerX = document.getElementById('health-container-x');
            const healthContainerO = document.getElementById('health-container-o');
            const charX = document.getElementById('player-x-char');
            const charO = document.getElementById('player-o-char');
            const modal = document.getElementById('character-select-modal');
            const presetCharsContainer = document.getElementById('preset-characters');
            const modalUploadInput = document.getElementById('modal-upload');
            const notificationModal = document.getElementById('notification-modal');
            const notificationText = document.getElementById('notification-text');
            const notificationCloseButton = document.getElementById('notification-close-button');
            const menuMusic = document.getElementById('menu-music');
            const battleMusic = document.getElementById('battle-music');
            const attackSound = document.getElementById('attack-sound');
            const hitSound = document.getElementById('hit-sound');
            const victorySound = document.getElementById('victory-sound');
            const shieldSound = document.getElementById('shield-sound');
            const bombSound = document.getElementById('bomb-sound');
            const clickSound = document.getElementById('click-sound');
            const teleportSound = document.getElementById('teleport-sound');
            const healSound = document.getElementById('heal-sound');
            const skillsMainContainer = document.getElementById('skills-container');
            const skillsXContainer = document.querySelector('#skills-x');
            const skillsOContainer = document.querySelector('#skills-o');
            const turnAnnouncementContainer = document.getElementById('turn-announcement');
            const turnAnnouncementText = document.getElementById('turn-announcement-text');
            const winningLaserLine = document.getElementById('winning-laser-line');
            const historyToggleButton = document.getElementById('history-toggle-button');
            const historyPanel = document.getElementById('history-panel');
            const historyLogContent = document.getElementById('history-log-content');
            const campaignButton = document.getElementById('campaign-button');
            const campaignMapScreen = document.getElementById('campaign-map-screen');
            const campaignLevelGrid = document.getElementById('campaign-level-grid');
            const backToMenuFromCampaignButton = document.getElementById('back-to-menu-from-campaign');
            const tutorialButton = document.getElementById('tutorial-button');
            const tutorialScreen = document.getElementById('tutorial-screen');
            const backToMenuFromTutorialButton = document.getElementById('back-to-menu-from-tutorial');
            const tutorialSkillsList = document.getElementById('tutorial-skills-list');
            const levelDetailModal = document.getElementById('level-detail-modal');
            const levelModalTitle = document.getElementById('level-modal-title');
            const modalMissionText = document.getElementById('modal-mission-text');
            const modalDifficultyText = document.getElementById('modal-difficulty-text');
            const modalAiSkills = document.getElementById('modal-ai-skills');
            const modalSpecialConditions = document.getElementById('modal-special-conditions');
            const modalSpecialConditionsText = document.getElementById('modal-special-conditions-text');
            const closeLevelModalButton = document.getElementById('close-level-modal');
            const battleArena = document.querySelector('.battle-arena');
            
            // ELEMENTOS DE PAUSE ADICIONADOS
            const pauseButton = document.getElementById('pause-button');
            const pauseModal = document.getElementById('pause-modal');
            const resumeButton = document.getElementById('resume-button');
            const quitMatchButton = document.getElementById('quit-match-button');
            
            // --- CONSTANTS ---
            const X_CLASS = 'x', O_CLASS = 'o';
            const WINNING_COMBINATIONS = [ [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6] ];
            const MAX_MOVES = 3, DAMAGE_PER_POINT = 20, HEALTH_DRAIN_PER_SECOND = 0.5, HEAL_AMOUNT = 25;
            const PRESET_EMOJIS = ['ü¶∏','ü•∑','ü§ñ','üëπ','üë®‚ÄçüöÄ','üßõ','üßô','üßü'];
            const DEFAULT_AVATAR_X = { type: 'image', value: 'https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/main/person1.png' };
            const DEFAULT_AVATAR_O = { type: 'image', value: 'https://raw.githubusercontent.com/Caioxm1/jogo-da-velha/main/person2.png' };
            const AI_SKILL_POOL = ['bomb', 'heal', 'shield', 'sacrifice', 'mirror', 'swap', 'shove'];
            
            // SKILLS DATA STRUCTURE
            const ALL_SKILLS = {
                'heal': { id: 'heal', name: 'Cura', icon: '‚ù§Ô∏è‚Äçü©π', description: 'Recupera 25 de vida.', type: 'active', implemented: true },
                'bomb': { id: 'bomb', name: 'Bomba', icon: 'üí£', description: 'Remove uma pe√ßa inimiga e interdita a c√©lula por 1 turno.', type: 'active', implemented: true },
                'shield': { id: 'shield', name: 'Escudo', icon: 'üõ°Ô∏è', description: 'Bloqueia o pr√≥ximo ataque inimigo.', type: 'active', implemented: true },
                'vampirism': { id: 'vampirism', name: 'Vampirismo', icon: 'ü©∏', description: 'Cura 50% do dano causado ao pontuar.', type: 'passive', implemented: true },
                'sacrifice': { id: 'sacrifice', name: 'Sacrif√≠cio', icon: 'üíÄ', description: 'Destr√≥i uma pe√ßa sua para DOBRAR o dano do pr√≥ximo ponto.', type: 'active', implemented: true },
                'swap': { id: 'swap', name: 'Troca', icon: 'üîÅ', description: 'Troca a posi√ß√£o de duas pe√ßas no tabuleiro.', type: 'active', implemented: true },
                'shove': { id: 'shove', name: 'Empurr√£o', icon: 'üñêÔ∏è', description: 'Empurra uma pe√ßa para uma casa vazia adjacente.', type: 'active', implemented: true },
                'mirror': { id: 'mirror', name: 'Espelho', icon: 'ü™û', description: 'Cancela a pr√≥xima habilidade inimiga.', type: 'active', implemented: true },
            };

            const LEVEL_CONFIG = Array.from({ length: 80 }, (_, i) => {
                const level = i + 1;
                if (level <= 9) return { level, aiName: `Aspirante Nv. ${level}`, aiDifficulty: 'easy', aiSkills: [], mission: { description: "Ven√ßa a partida.", isCompleted: (gd) => gd.playerWon } };
                if (level === 10) return { level, aiName: "Guardi√£o da Cura", aiDifficulty: 'easy', aiSkills: ['heal'], unlocksSkill: 'heal', mission: { description: "Ven√ßa para desbloquear a Cura ‚ù§Ô∏è‚Äçü©π.", isCompleted: (gd) => gd.playerWon } };
                if (level === 11) return { level, aiName: "Guardi√£o do Port√£o", aiDifficulty: 'normal', aiSkills: ['shield'], gate: { requiredTier: 1, requiredPercentage: 0.8 }, mission: { description: "Prove seu valor para avan√ßar.", isCompleted: (gd) => gd.playerWon } };
                if (level <= 19) { const m = [ { description: "Ven√ßa com mais de 50 de vida.", isCompleted: (gd) => gd.playerWon && gd.playerFinalHealth > 50 }, { description: "Ven√ßa em 20 turnos ou menos.", isCompleted: (gd) => gd.playerWon && gd.turnCount <= 20 }, { description: "Ven√ßa sem que a IA fa√ßa pontos.", isCompleted: (gd) => gd.playerWon && gd.opponentPoints === 0 } ]; return { level, aiName: ["O Estrategista", "O Defensor", "O T√°tico"][(level-12) % 3], aiDifficulty: 'normal', aiSkills: ['heal', 'bomb'], mission: m[(level-12)%3] }; }
                if (level === 20) return { level, aiName: "Mestre das Bombas", aiDifficulty: 'normal', aiSkills: ['bomb', 'shield'], unlocksSkill: 'bomb', mission: { description: "Ven√ßa usando a habilidade Cura ‚ù§Ô∏è‚Äçü©π para desbloquear a Bomba üí£.", isCompleted: (gd) => gd.playerWon && gd.skillsUsed.includes('heal') } };
                if (level === 21) return { level, aiName: "Guardi√£o T√°tico", aiDifficulty: 'normal', aiSkills: ['sacrifice', 'shield'], gate: { requiredTier: 2, requiredPercentage: 0.8 }, mission: { description: "Mostre sua habilidade t√°tica.", isCompleted: (gd) => gd.playerWon } };
                if (level <= 29) { const m=[{description:"Ven√ßa com mais de 70 de vida.",isCompleted:(gd)=>gd.playerWon&&gd.playerFinalHealth>70},{description:"Ven√ßa usando Bomba üí£ pelo menos uma vez.",isCompleted:(gd)=>gd.playerWon&&gd.skillsUsed.includes('bomb')},{description:"Ven√ßa sem que a IA fa√ßa mais de 1 ponto.",isCompleted:(gd)=>gd.playerWon&&gd.opponentPoints<=1}]; return {level,aiName:["O Defensor Implac√°vel", "O Agressor Calculista", "A Muralha"][(level-22)%3],aiDifficulty:'normal',aiSkills:['heal','bomb','shield'],mission:m[(level-22)%3]};}
                if (level === 30) return { level, aiName: "O Protetor da Arena", aiDifficulty: 'normal', aiSkills: ['shield', 'heal'], unlocksSkill: 'shield', mission: { description: "Ven√ßa para desbloquear o Escudo üõ°Ô∏è.", isCompleted: (gd) => gd.playerWon } };
                if (level === 31) return { level, aiName: "Guardi√£o dos Enigmas", aiDifficulty: 'hard', aiSkills: ['swap', 'mirror'], gate: { requiredTier: 3, requiredPercentage: 0.8 }, mission: { description: "Resolva este desafio para prosseguir.", isCompleted: (gd) => gd.playerWon } };
                if (level <= 39) { const m=[{description:"Ven√ßa com sua vida abaixo de 40.",isCompleted:(gd)=>gd.playerWon&&gd.playerFinalHealth<40},{description:"Ven√ßa SEM usar a habilidade Bomba üí£.",isCompleted:(gd)=>gd.playerWon&&!gd.skillsUsed.includes('bomb')},{description:"Ven√ßa SEM usar a habilidade Cura ‚ù§Ô∏è‚Äçü©π.",isCompleted:(gd)=>gd.playerWon&&!gd.skillsUsed.includes('heal')}]; return {level,aiName:["O Ilusionista", "O Mestre das Restri√ß√µes", "O Trapaceiro"][(level-32)%3],aiDifficulty:'hard',aiSkills:['swap','shove','mirror'],mission:m[(level-32)%3]};}
                if (level === 40) return { level, aiName: "O Lorde Sanguin√°rio", aiDifficulty: 'hard', aiSkills: ['vampirism', 'sacrifice'], unlocksSkill: 'vampirism', mission: { description: "Derrote o lorde para aprender a arte do Vampirismo ü©∏.", isCompleted: (gd) => gd.playerWon } };
                if (level === 41) return { level, aiName: "Guardi√£o do Pante√£o", aiDifficulty: 'hard', aiSkills: ['mirror', 'shield', 'swap'], gate: { requiredTier: 4, requiredPercentage: 0.8 }, mission: { description: "Apenas os mestres passam daqui.", isCompleted: (gd) => gd.playerWon } };
                if (level <= 49) { const m=[{description:"Ven√ßa com sua vida abaixo de 30.",isCompleted:(gd)=>gd.playerWon&&gd.playerFinalHealth<30},{description:"Ven√ßa um oponente com 120 de vida inicial.",isCompleted:(gd)=>gd.playerWon,customInitialHealth:{o:120}},{description:"Ven√ßa SEM usar habilidades defensivas (Escudo, Espelho).",isCompleted:(gd)=>gd.playerWon&&!gd.skillsUsed.includes('shield')&&!gd.skillsUsed.includes('mirror')}]; return {level,aiName:["O Mestre da Confus√£o","O Manipulador","O Arquiteto da Dor"][(level-42)%3],aiDifficulty:'hard',aiSkills:['sacrifice','shove','mirror'],mission:m[(level-42)%3]};}
                if (level === 50) return { level, aiName: "O Lorde do Sacrif√≠cio", aiDifficulty: 'hard', aiSkills: ['sacrifice', 'vampirism', 'shield'], unlocksSkill: 'sacrifice', mission: { description: "Domine o poder do sacrif√≠cio para desbloquear a habilidade üíÄ.", isCompleted: (gd) => gd.playerWon } };
                if (level === 51) return { level, aiName: "Guardi√£o Enigm√°tico", aiDifficulty: 'hard', aiSkills: ['swap', 'mirror', 'shield'], gate: { requiredTier: 6, requiredPercentage: 0.8 }, mission: { description: "Prove sua maestria t√°tica para avan√ßar.", isCompleted: (gd) => gd.playerWon } };
                if (level <= 59) { const m=[{description:"Ven√ßa ap√≥s usar a habilidade Sacrif√≠cio üíÄ.",isCompleted:(gd)=>gd.playerWon&&gd.skillsUsed.includes('sacrifice')},{description:"Ven√ßa trocando uma pe√ßa sua com uma pe√ßa inimiga.",isCompleted:(gd)=>gd.playerWon&&gd.swappedOwnWithEnemy},{description:"Ven√ßa a partida sem que suas pe√ßas ocupem o centro (casa 5).",isCompleted:(gd)=>gd.playerWon&&!gd.playerUsedCenter}]; return {level,aiName:["O Mestre da Troca","O Ilusionista","O Estrategista Ca√≥tico"][(level-52)%3],aiDifficulty:'hard',aiSkills:['swap','shove','bomb'],mission:m[(level-52)%3]};}
                if (level === 60) return { level, aiName: "O Ilusionista do Tabuleiro", aiDifficulty: 'hard', aiSkills: ['swap', 'mirror', 'shove'], unlocksSkill: 'swap', mission: { description: "Derrote o mestre da ilus√£o para desbloquear a Troca üîÅ.", isCompleted: (gd) => gd.playerWon } };
                if (level === 61) return { level, aiName: "Guardi√£o do Pante√£o", aiDifficulty: 'hard', aiSkills: ['mirror', 'shield', 'swap'], gate: { requiredTier: 6, requiredPercentage: 0.8 }, mission: { description: "Apenas os mestres passam daqui.", isCompleted: (gd) => gd.playerWon } };
                if (level <= 69) { const m=[{description:"Ven√ßa um oponente Tit√£ com 150 de vida.",isCompleted:(gd)=>gd.playerWon,customInitialHealth:{o:150}},{description:"Ven√ßa sem que a IA fa√ßa mais de 1 ponto.",isCompleted:(gd)=>gd.playerWon&&gd.opponentPoints<=1},{description:"Ven√ßa usando 3 habilidades ativas diferentes.",isCompleted:(gd)=>gd.playerWon&&gd.skillsUsed.length>=3}]; return {level,aiName:["Lenda Viva","Tit√£ da Arena","Campe√£o Implac√°vel"][(level-62)%3],aiDifficulty:'hard',aiSkills:['swap','shove','sacrifice','shield'],mission:m[(level-62)%3]};}
                if (level === 70) return { level, aiName: "Mestre do Posicionamento", aiDifficulty: 'hard', aiSkills: ['shove', 'swap', 'bomb'], unlocksSkill: 'shove', mission: { description: "Derrote o mestre da manipula√ß√£o para desbloquear o Empurr√£o üñêÔ∏è.", isCompleted: (gd) => gd.playerWon } };
                if (level === 71) return { level, aiName: "O √öltimo Guardi√£o", aiDifficulty: 'hard', aiSkills: ['mirror', 'shield', 'shove', 'swap'], gate: { requiredTier: 7, requiredPercentage: 0.8 }, mission: { description: "Apenas a lenda viva pode passar.", isCompleted: (gd) => gd.playerWon } };
                if (level <= 79) { const m=[{description:"Ven√ßa um oponente com 200 de vida.",isCompleted:(gd)=>gd.playerWon,customInitialHealth:{o:200}},{description:"Ven√ßa a partida sem que o oponente fa√ßa NENHUM ponto.",isCompleted:(gd)=>gd.playerWon&&gd.opponentPoints===0},{description:"Ven√ßa com suas 3 pe√ßas em uma diagonal.",isCompleted:(gd)=>gd.playerWon&&gd.wonOnDiagonal}]; return {level,aiName:["A Lenda Suprema","Deus da Arena","O Invenc√≠vel"][(level-72)%3],aiDifficulty:'hard',aiSkills:['mirror','shove','sacrifice','swap','shield'],mission:m[(level-72)%3]};}
                if (level === 80) return { level, aiName: "O Campe√£o Supremo", aiDifficulty: 'hard', aiSkills: ['mirror', 'shield', 'swap', 'shove', 'sacrifice'], unlocksSkill: 'mirror', mission: { description: "Derrote a lenda para desbloquear o Espelho ü™û e completar sua jornada.", isCompleted: (gd) => gd.playerWon } };
                
                return null;
            }).filter(Boolean);
            
            // --- STATE VARIABLES ---
            let cellElements, isOTurn, movesX, movesO, healthX, healthO, drainInterval, isGameActive,
                playerToEdit, gameMode = null, selectedSubMode = null, aiDifficulty = 'normal', aiTimeout,
                skills, targetingState = null, eventManager, interdictedCellIndex = -1,
                savedPlayerName = '', currentScreenElement = null, playerSkillKit = [];
            
            let isPaused = false; // VARI√ÅVEL DE ESTADO PARA O PAUSE

            let turnCount, playerSkillsUsed, opponentPoints, swappedOwnWithEnemy, playerUsedCenter, wonOnDiagonal;
            
            let playerXAvatar = { ...DEFAULT_AVATAR_X };
            let playerOAvatar = { ...DEFAULT_AVATAR_O };

            let campaignProgress = {
                unlockedSkills: [], 
                completedMissions: [], 
                highestLevelUnlocked: 1,
                unlockedThirdSlot: false
            };
            let currentLevelData = null; 
            
            // NOVO: Classe que controla os eventos da Arena Ca√≥tica
            class ArenaEventManager {
                constructor() {
                    this.hasActiveEvent = false;
                    this.cursedCell = { index: -1, turnsLeft: 0 };
                    this.minedCell = { index: -1, turnsLeft: 0 };
                    this.portals = { cells: [], turnsLeft: 0 };
                    this.blackHole = { index: -1, turnsLeft: 0 };
                    this.meteorShower = { turnsLeft: 0 };
                    this.powerInversionActive = false;
                    this.foggyCells = [];
                }

                stop() {
                    this.clearAllEvents();
                }

                clearAllEvents() {
                    if (this.cursedCell.index > -1 && cellElements[this.cursedCell.index]) cellElements[this.cursedCell.index].classList.remove('cursed');
                    if (this.minedCell.index > -1 && cellElements[this.minedCell.index]) cellElements[this.minedCell.index].classList.remove('mined');
                    this.portals.cells.forEach(c => c.classList.remove('portal'));
                    if (this.blackHole.index > -1 && cellElements[this.blackHole.index]) cellElements[this.blackHole.index].classList.remove('black-hole');
                    this.foggyCells.forEach(c => c.classList.remove('foggy'));
                    healthContainerX.classList.remove('power-inversion-glow');
                    healthContainerO.classList.remove('power-inversion-glow');
                    
                    this.cursedCell = { index: -1, turnsLeft: 0 };
                    this.minedCell = { index: -1, turnsLeft: 0 };
                    this.portals = { cells: [], turnsLeft: 0 };
                    this.hasActiveEvent = false;
                    this.blackHole = { index: -1, turnsLeft: 0 };
                    this.meteorShower = { turnsLeft: 0 };
                    this.powerInversionActive = false; 
                    this.foggyCells = [];
                    delete this.powerInversionTurn;
                    delete this.foggyCells.turnCreated;
                }

                consumeAndRefresh() {
                    this.clearAllEvents(); 
                    setTimeout(() => this.triggerRandomEvent(), 500);
                }

                triggerRandomEvent() {
                    if (!isGameActive) return;
                    this.clearAllEvents();

                    const availableCells = cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS));
                    if (availableCells.length < 1) return;
                    
                    this.hasActiveEvent = true;
                    const eventType = Math.floor(Math.random() * 7);
                    
                    switch (eventType) {
                        case 0: this._triggerCursedCell(availableCells); break;
                        case 1: this._triggerMinedCell(availableCells); break;
                        case 2: this._triggerPortals(availableCells); break;
                        case 3: this._triggerBlackHole(availableCells); break;
                        case 4: this._triggerPowerInversion(); break;
                        case 5: this._triggerMeteorShower(); break;
                        case 6: this._triggerFogOfWar(); break;
                    }
                }
                
                _triggerCursedCell(availableCells) {
                    const cellToCurse = availableCells[Math.floor(Math.random() * availableCells.length)];
                    this.cursedCell = { index: cellElements.indexOf(cellToCurse), turnsLeft: 3 };
                    cellToCurse.classList.add('cursed');
                    logAction(`Evento: C√©lula Amaldi√ßoada! Ela desaparecer√° em 3 turnos.`, 'system-log');
                }
                
                _triggerMinedCell(availableCells) {
                    const cellToMine = availableCells[Math.floor(Math.random() * availableCells.length)];
                    this.minedCell = { index: cellElements.indexOf(cellToMine), turnsLeft: 3 };
                    cellToMine.classList.add('mined');
                    logAction(`Evento: C√©lula Minada üí•! Ela explodir√° em 3 turnos se n√£o for ativada.`, 'system-log');
                }

                _triggerPortals(availableCells) {
                    if (availableCells.length < 2) return this.triggerRandomEvent();
                    let idx1 = Math.floor(Math.random() * availableCells.length);
                    let idx2;
                    do { idx2 = Math.floor(Math.random() * availableCells.length); } while (idx1 === idx2);
                    this.portals = { cells: [availableCells[idx1], availableCells[idx2]], turnsLeft: 3 };
                    this.portals.cells.forEach(c => c.classList.add('portal'));
                    logAction(`Evento: Portais üåÄ apareceram! Eles se fechar√£o em 3 turnos.`, 'system-log');
                }

                _triggerBlackHole(availableCells) {
                    const cellToConsume = availableCells[Math.floor(Math.random() * availableCells.length)];
                    this.blackHole = { index: cellElements.indexOf(cellToConsume), turnsLeft: 2 };
                    cellToConsume.classList.add('black-hole');
                    logAction(`Evento: Um Buraco Negro ‚ö´ surgiu e desativar√° uma c√©lula por 2 turnos!`, 'system-log');
                }
                
                _triggerPowerInversion() {
                    this.powerInversionActive = true;
                    if (healthX < healthO) healthContainerX.classList.add('power-inversion-glow');
                    else if (healthO < healthX) healthContainerO.classList.add('power-inversion-glow');
                    logAction(`Evento: Invers√£o de Poder ‚ö°! O jogador com menos vida causar√° dano extra!`, 'system-log');
                }
                
                _triggerMeteorShower() {
                    this.meteorShower.turnsLeft = 1; // Strikes on the next turn swap
                    logAction(`Evento: O c√©u escurece... Uma Chuva de Meteoros ‚òÑÔ∏è se aproxima!`, 'system-log');
                }

                _triggerFogOfWar() {
                    const occupiedCells = cellElements.filter(c => c.classList.contains(X_CLASS) || c.classList.contains(O_CLASS));
                    if (occupiedCells.length < 1) return this.triggerRandomEvent();
                    this.foggyCells = occupiedCells.sort(() => 0.5 - Math.random()).slice(0, 3);
                    this.foggyCells.forEach(c => c.classList.add('foggy'));
                    logAction(`Evento: N√©voa de Batalha ÔøΩÔ∏è! A identidade de algumas pe√ßas foi ocultada!`, 'system-log');
                }

                isCursed(cell) { return this.cursedCell.index !== -1 && cellElements.indexOf(cell) === this.cursedCell.index; }
                isMined(cell) { return this.minedCell.index !== -1 && cellElements.indexOf(cell) === this.minedCell.index; }
                getOtherPortal(cell) { return this.portals.cells.find(p => p !== cell); }

                triggerMine(playerClass) {
                    const damage = 15;
                    const playerChar = playerClass === X_CLASS ? 'x' : 'o';
                    showFloatingText(playerChar, `-${damage}`, 'damage');
                    playSound(bombSound);
                    const playerName = playerClass === X_CLASS ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText;
                    logAction(`${playerName} ativou uma mina üí• e sofreu ${damage} de dano!`, `player-${playerClass}-log`);
                    if (playerClass === X_CLASS) healthX = Math.max(0, healthX - damage);
                    else healthO = Math.max(0, healthO - damage);
                    updateHealthBars();
                    this.consumeAndRefresh();
                    if (healthX <= 0 || healthO <= 0) endGame();
                }
            }

            // --- MUSIC AND NAVIGATION CONTROL ---
            function updateMusic(currentScreen) {
                if (currentScreen === gameScreen) {
                    stopMenuMusic();
                    playBattleMusic();
                    historyToggleButton.classList.add('visible');
                    pauseButton.classList.add('visible'); // MOSTRA o bot√£o de pause
                } else {
                    stopBattleMusic();
                    playMenuMusic();
                    historyToggleButton.classList.remove('visible');
                    pauseButton.classList.remove('visible'); // ESCONDE o bot√£o de pause
                    historyPanel.classList.remove('show');
                }
            }
            
            function playMenuMusic() { stopBattleMusic(); if (menuMusic.paused) menuMusic.play().catch(() => {}); }
            function stopMenuMusic() { menuMusic.pause(); menuMusic.currentTime = 0; }
            function playBattleMusic() { stopMenuMusic(); if (battleMusic.paused) battleMusic.play().catch(() => {}); }
            function stopBattleMusic() { battleMusic.pause(); battleMusic.currentTime = 0; }
            
            function showScreen(screenToShow, direction = 'forward') {
                if(direction === 'none') {
                    if(currentScreenElement) currentScreenElement.classList.remove('active');
                    screenToShow.classList.add('active');
                    currentScreenElement = screenToShow;
                    updateMusic(screenToShow);
                    return;
                }
                if (currentScreenElement && currentScreenElement !== screenToShow) {
                    const outClass = direction === 'forward' ? 'slide-out-to-left' : 'slide-out-to-right';
                    currentScreenElement.classList.remove('active');
                    currentScreenElement.classList.add(outClass);
                    currentScreenElement.addEventListener('animationend', () => {
                        currentScreenElement.classList.remove(outClass);
                    }, { once: true });
                }
                
                const inClass = direction === 'forward' ? 'slide-in-from-right' : 'slide-in-from-left';
                screenToShow.classList.remove('slide-out-to-left', 'slide-out-to-right');
                screenToShow.classList.add('active', inClass);
                screenToShow.addEventListener('animationend', () => {
                    screenToShow.classList.remove(inClass);
                }, { once: true });
                
                currentScreenElement = screenToShow;
                updateMusic(screenToShow);
                winningMessageElement.classList.remove('show');
            }
            
            // --- HELPER FUNCTIONS ---
            function playSound(sound) { if(sound) { sound.currentTime = 0; sound.play().catch(e => {}); } }
            
            function showNotification(message) {
                notificationText.innerHTML = message;
                notificationModal.classList.add('show');
            }
            
            function getRandomSkills(pool, count) {
                const shuffled = [...pool].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }

            function logAction(message, playerClass = 'system-log') {
                const logEntry = document.createElement('div');
                logEntry.classList.add('log-entry', playerClass);
                logEntry.innerHTML = message;
                historyLogContent.prepend(logEntry);
            }

            function getAdjacentCells(index) {
                const adjacent = [];
                const isTopRow = index < 3;
                const isBottomRow = index > 5;
                const isLeftCol = index % 3 === 0;
                const isRightCol = index % 3 === 2;

                if (!isTopRow) adjacent.push(index - 3);
                if (!isBottomRow) adjacent.push(index + 3);
                if (!isLeftCol) adjacent.push(index - 1);
                if (!isRightCol) adjacent.push(index + 1);

                return adjacent.filter(i => i >= 0 && i < 9);
            }
            
            function getMaxKitSize() {
                if (gameMode === 'campaign') { return 2; } 
                return campaignProgress.unlockedThirdSlot ? 3 : 2;
            }

            // NOVA FUN√á√ÉO PARA TEXTO FLUTUANTE
            function showFloatingText(player, text, type) {
                if (!battleArena) return;

                const textElement = document.createElement('div');
                textElement.classList.add('floating-text', `player-${player}`, type);
                textElement.textContent = text;

                if (player === 'o') {
                    textElement.style.setProperty('--translateX', '50%');
                }

                battleArena.appendChild(textElement);

                setTimeout(() => {
                    textElement.remove();
                }, 1500);
            }

            // --- ARSENAL AND PROFILE LOGIC ---
            function loadData() {
                savedPlayerName = localStorage.getItem('arenaPlayerName');
                const savedAvatarJSON = localStorage.getItem('arenaPlayerAvatar');
                const savedKitJSON = localStorage.getItem('arenaPlayerKit');
                
                if (savedPlayerName) {
                    playerXAvatar = savedAvatarJSON ? JSON.parse(savedAvatarJSON) : { ...DEFAULT_AVATAR_X };
                    playerSkillKit = savedKitJSON ? JSON.parse(savedKitJSON) : [];
                    arsenalPlayerNameInput.value = savedPlayerName;
                    applyAvatar(arsenalCharPreview, playerXAvatar);
                }
                
                loadCampaignProgress();

                if (savedPlayerName) {
                    showScreen(modeSelectMenu, 'none');
                } else {
                    showScreen(arsenalScreen, 'none');
                }
                changeArsenalButton.click();
                showScreen(savedPlayerName ? modeSelectMenu : arsenalScreen, 'none');
            }
            
            function populateArsenalScreen() {
                skillDeckGrid.innerHTML = '';
                playerKitSlots.innerHTML = '';
                const maxKitSize = getMaxKitSize();

                playerKitTitle.textContent = `Seu Kit de Batalha (Escolha ${maxKitSize})`;
                const unlockedSkills = campaignProgress.unlockedSkills; 

                if(unlockedSkills.length === 0){
                    skillDeckGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--cor-celula);">Nenhuma habilidade desbloqueada. Jogue o modo Campanha!</p>`;
                } else {
                    unlockedSkills.forEach(skillId => {
                        const skill = ALL_SKILLS[skillId];
                        if (!skill) return;
                        const card = document.createElement('div');
                        card.className = 'skill-card';
                        card.dataset.skillId = skill.id;
                        card.innerHTML = `<div class="skill-icon">${skill.icon}</div><div class="skill-name">${skill.name}</div>`;
                        card.title = skill.description;
                        if (playerSkillKit.includes(skill.id)) card.classList.add('selected');
                        card.addEventListener('click', () => handleSkillSelection(skill.id));
                        skillDeckGrid.appendChild(card);
                    });
                }

                for(let i = 0; i < maxKitSize; i++) {
                    const kitSlot = document.createElement('div');
                    kitSlot.className = 'kit-slot';
                    const skillId = playerSkillKit[i];
                    if (skillId && ALL_SKILLS[skillId]) {
                        const skill = ALL_SKILLS[skillId];
                        kitSlot.innerHTML = `<div class="skill-card selected" title="${skill.description}"><div class="skill-icon">${skill.icon}</div><div class="skill-name">${skill.name}</div></div>`;
                    }
                    playerKitSlots.appendChild(kitSlot);
                }
            }
            
            function handleSkillSelection(skillId) {
                const skillIndex = playerSkillKit.indexOf(skillId);
                const maxKitSize = getMaxKitSize();
                
                if (skillIndex > -1) {
                    playerSkillKit.splice(skillIndex, 1);
                } else {
                    if (playerSkillKit.length >= maxKitSize) {
                        showNotification(`Seu kit j√° tem ${maxKitSize} habilidades. Remova uma para adicionar outra.`);
                        return;
                    }
                    playerSkillKit.push(skillId);
                }
                populateArsenalScreen();
            }
            
            function saveArsenalAndProceed() {
                const name = arsenalPlayerNameInput.value.trim();
                if (name) {
                    savedPlayerName = name;
                    localStorage.setItem('arenaPlayerName', name);
                    localStorage.setItem('arenaPlayerAvatar', JSON.stringify(playerXAvatar));
                    localStorage.setItem('arenaPlayerKit', JSON.stringify(playerSkillKit));
                    showScreen(modeSelectMenu, 'forward');
                } else {
                    showNotification('Por favor, digite seu nome de jogador.');
                }
            }

            // --- CAMPAIGN LOGIC ---
            function saveCampaignProgress() {
                localStorage.setItem('arenaCampaignProgress', JSON.stringify(campaignProgress));
            }

            function loadCampaignProgress() {
                const savedProgress = localStorage.getItem('arenaCampaignProgress');
                if (savedProgress) {
                    campaignProgress = JSON.parse(savedProgress);
                }
            }

            function showCampaignMap() {
                campaignLevelGrid.innerHTML = ''; 
                LEVEL_CONFIG.forEach(levelData => {
                    if (!levelData) return;
                    const levelButton = document.createElement('button');
                    levelButton.className = 'menu-button';
                    levelButton.innerHTML = `${levelData.level}<br><small style="font-size: 0.7rem; font-weight: 400;">${levelData.aiName}</small>`;
                    let isLocked = levelData.level > campaignProgress.highestLevelUnlocked;
                    if (levelData.gate && isLocked) {
                        const { requiredTier, requiredPercentage } = levelData.gate;
                        const tierStart = (requiredTier - 1) * 10 + 1;
                        const tierEnd = requiredTier * 10;
                        const tierLevels = LEVEL_CONFIG.filter(l => l && l.level >= tierStart && l.level <= tierEnd);
                        const completedInTier = tierLevels.filter(l => campaignProgress.completedMissions.includes(l.level)).length;
                        const currentPercentage = tierLevels.length > 0 ? (completedInTier / tierLevels.length) : 0;
                        if (currentPercentage >= requiredPercentage) {
                            isLocked = false;
                            if (levelData.level > campaignProgress.highestLevelUnlocked) {
                                campaignProgress.highestLevelUnlocked = levelData.level;
                                saveCampaignProgress();
                            }
                        } else {
                            levelButton.title = `Complete ${Math.round(requiredPercentage * 100)}% (${completedInTier}/${tierLevels.length}) das miss√µes do Ato ${tierStart}-${tierEnd} para desbloquear.`;
                            levelButton.innerHTML += ` <span style="font-size: 1.2rem; display: block;">üîí</span>`;
                        }
                    }
                    if (isLocked) {
                        levelButton.disabled = true;
                    } else {
                        if (campaignProgress.completedMissions.includes(levelData.level)) {
                            levelButton.classList.add('mission-complete');
                            levelButton.innerHTML += ` <span style="font-size: 0.8rem; display: block;">‚úîÔ∏è</span>`;
                        } else {
                            levelButton.title = `Miss√£o: ${levelData.mission.description}`;
                        }
                        levelButton.addEventListener('click', () => showLevelDetails(levelData));
                    }
                    campaignLevelGrid.appendChild(levelButton);
                });
                showScreen(campaignMapScreen, 'forward');
            }
            
            function showLevelDetails(levelData) {
                if (!levelData) return;
                levelModalTitle.textContent = `N√≠vel ${levelData.level}: ${levelData.aiName}`;
                modalMissionText.textContent = levelData.mission.description;
                const difficulty = levelData.aiDifficulty;
                modalDifficultyText.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                modalAiSkills.innerHTML = '';
                if (levelData.aiSkills.length > 0) {
                    levelData.aiSkills.forEach(skillId => {
                        const skill = ALL_SKILLS[skillId];
                        if (skill) {
                            const skillDisplay = document.createElement('button');
                            skillDisplay.className = 'skill-button';
                            skillDisplay.innerHTML = skill.icon;
                            skillDisplay.title = `${skill.name}: ${skill.description}`;
                            modalAiSkills.appendChild(skillDisplay);
                        }
                    });
                } else {
                    modalAiSkills.innerHTML = '<p style="font-size: 0.9rem; font-style: italic;">Nenhuma habilidade especial.</p>';
                }
                if (levelData.customInitialHealth && levelData.customInitialHealth.o > 100) {
                    modalSpecialConditionsText.textContent = `O oponente √© um Tit√£ e come√ßa com ${levelData.customInitialHealth.o} de vida!`;
                    modalSpecialConditions.style.display = 'block';
                } else {
                    modalSpecialConditions.style.display = 'none';
                }
                let currentStartButton = document.getElementById('start-level-from-modal');
                const newStartButton = currentStartButton.cloneNode(true);
                newStartButton.addEventListener('click', () => {
                    levelDetailModal.classList.remove('show');
                    startCampaignLevel(levelData.level);
                });
                currentStartButton.replaceWith(newStartButton);
                levelDetailModal.classList.add('show');
            }

            function startCampaignLevel(levelNumber) {
                currentLevelData = LEVEL_CONFIG.find(l => l && l.level === levelNumber);
                if (!currentLevelData) return;
                gameMode = 'campaign';
                aiDifficulty = currentLevelData.aiDifficulty;
                initializeMatch();
                showScreen(gameScreen, 'forward');
            }
            
            function handleCampaignEnd(gameData) {
                const missionAccomplished = currentLevelData.mission.isCompleted(gameData);
                let message = "";
                if (gameData.playerWon) {
                    if (missionAccomplished) {
                        message = `Miss√£o Cumprida!`;
                        if (!campaignProgress.completedMissions.includes(currentLevelData.level)) {
                            campaignProgress.completedMissions.push(currentLevelData.level);
                        }
                        const nextLevel = currentLevelData.level + 1;
                        const nextLevelData = LEVEL_CONFIG.find(l => l && l.level === nextLevel);
                        if (nextLevel > campaignProgress.highestLevelUnlocked && nextLevelData && !nextLevelData.gate) {
                            campaignProgress.highestLevelUnlocked = nextLevel;
                        }
                        if (currentLevelData.unlocksSkill) {
                            const skillId = currentLevelData.unlocksSkill;
                            if (!campaignProgress.unlockedSkills.includes(skillId)) {
                                campaignProgress.unlockedSkills.push(skillId);
                                const skill = ALL_SKILLS[skillId];
                                message += `<br><br><small>Nova Habilidade: ${skill.icon} ${skill.name}!</small>`;
                            }
                        }
                    } else {
                        message = `Vit√≥ria! <br><small>(Miss√£o: ${currentLevelData.mission.description} - Falhou)</small>`;
                    }
                    if (currentLevelData.level === 35 && !campaignProgress.unlockedThirdSlot) {
                        campaignProgress.unlockedThirdSlot = true;
                        const notificationMessage = `<h3>Arsenal Expandido!</h3><p>Voc√™ provou seu valor t√°tico. Como recompensa, o 3¬∫ slot de habilidade foi desbloqueado para os modos **Batalha T√°tica** e **Partida R√°pida**!</p><p><i>(Na Campanha, o desafio continua com 2 slots).</i></p>`;
                        showNotification(notificationMessage.replace(/\n\s+/g, '\n'));
                    }
                } else {
                    message = `Derrota!`;
                }
                saveCampaignProgress();
                winningMessageTextElement.innerHTML = message;
                winningMessageElement.classList.add('show');
                const winner = gameData.playerWon ? charX : charO;
                const loser = gameData.playerWon ? charO : charX;
                const winnerColor = gameData.playerWon ? 'var(--cor-x)' : 'var(--cor-o)';
                winner.style.setProperty('--winner-color', winnerColor);
                winner.classList.add('victory');
                loser.classList.add('defeat');
                boardElement.classList.add('locked');
            }
            
            // --- CORE GAME LOGIC ---
            function initializeMatch() {
                isPaused = false; // Garante que todo jogo comece sem estar pausado
                pauseModal.classList.remove('show'); // Esconde o modal de pause

                isGameActive = true;
                healthX = 100; healthO = 100;
                
                if(gameMode === 'campaign' && currentLevelData && currentLevelData.customInitialHealth) {
                    healthX = currentLevelData.customInitialHealth.x || 100;
                    healthO = currentLevelData.customInitialHealth.o || 100;
                }

                isOTurn = false; movesX = []; movesO = [];
                targetingState = null;
                interdictedCellIndex = -1;
                turnCount = 0;
                playerSkillsUsed = { x: [], o: [] };
                opponentPoints = 0;
                swappedOwnWithEnemy = false;
                playerUsedCenter = false;
                wonOnDiagonal = false;
                skills = { x: {}, o: {} };

                historyLogContent.innerHTML = '';
                logAction('A batalha come√ßou!');
                
                charX.className = 'character'; charO.className = 'character';
                charX.style.removeProperty('--player-color'); charO.style.removeProperty('--player-color');
                
                clearInterval(drainInterval); clearTimeout(aiTimeout);
                if(eventManager) eventManager.stop();
                eventManager = null;
                drainInterval = setInterval(drainHealth, 1000);
                
                boardElement.className = 'board';
                boardElement.innerHTML = '';
                boardElement.appendChild(winningLaserLine);
                for(let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.cellIndex = i;
                    boardElement.appendChild(cell);
                }
                cellElements = Array.from(boardElement.querySelectorAll('.cell'));
                
                const clickHandler = {
                    'local': handleLocalClick, 
                    'single': handleVsAiClick,
                    'tatico': handleTaticoClick, 
                    'caotico': handleCaoticClick,
                    'tatico_single': handleTaticoClick, 
                    'caotico_single': handleCaoticClick,
                    'campaign': handleTaticoClick,
                }[gameMode];
                
                cellElements.forEach(cell => cell.addEventListener('click', clickHandler));
                
                setupGameUI();
                updateHealthBars();
                updateOldestPieceIndicator();
                
                winningLaserLine.className = '';
                winningLaserLine.classList.remove('show');
                boardElement.classList.remove('dimmed-board');
                cellElements.forEach(cell => {
                    cell.classList.remove('winning-cell-pulse');
                    cell.style.removeProperty('--pulse-color');
                });
                
                setTimeout(showTurnAnnouncement, 500);
            }
            
            function setupGameUI() {
                const isVsAi = gameMode.includes('single') || gameMode === 'campaign';
                gamePlayerLabelX.innerText = savedPlayerName || 'Jogador X';
                
                if (isVsAi) {
                    if (gameMode === 'campaign' && currentLevelData) {
                        gamePlayerLabelO.innerText = currentLevelData.aiName;
                        playerOAvatar = { type: 'emoji', value: 'ü§ñ' };
                    } else {
                        playerNameOInput.value = `M√°quina (${aiDifficulty})`;
                        gamePlayerLabelO.innerText = playerNameOInput.value;
                        playerOAvatar = { type: 'emoji', value: 'ü§ñ' };
                    }
                } else {
                    if (!playerNameOInput.value) playerNameOInput.value = 'Jogador O';
                    gamePlayerLabelO.innerText = playerNameOInput.value;
                }
                
                applyAvatar(charX, playerXAvatar);
                applyAvatar(charO, playerOAvatar);
                
                const isTaticOrChaotic = gameMode.startsWith('tatico') || gameMode.startsWith('caotico') || gameMode === 'campaign';
                skillsMainContainer.classList.toggle('show', isTaticOrChaotic);
                
                if (isTaticOrChaotic) {
                    skills = {
                        x: { shieldActive: false, damageBoostActive: false, mirrorActive: false },
                        o: { shieldActive: false, damageBoostActive: false, mirrorActive: false }
                    };
                    
                    playerSkillKit.forEach(skillId => { if(ALL_SKILLS[skillId]) skills.x[skillId] = true; });
                
                    if (isVsAi) {
                        let aiSkillsList = [];
                        if (gameMode === 'campaign') {
                            aiSkillsList = currentLevelData.aiSkills;
                        } else {
                            let numberOfAiSkills = aiDifficulty === 'hard' ? 3 : aiDifficulty === 'normal' ? 2 : 1;
                            aiSkillsList = getRandomSkills(AI_SKILL_POOL, numberOfAiSkills);
                        }
                        
                        aiSkillsList.forEach(skillId => { if (ALL_SKILLS[skillId]) skills.o[skillId] = true; });
                        if (aiSkillsList.length > 0) logAction(`A IA entra na batalha com: ${aiSkillsList.map(id => ALL_SKILLS[id]?.icon || '').join(' ')}`);

                    } else { 
                        playerSkillKit.forEach(skillId => { if(ALL_SKILLS[skillId]) skills.o[skillId] = true; });
                    }
                    
                    setupSkillButtons();
                }
                
                if (gameMode.startsWith('caotico')) {
                    eventManager = new ArenaEventManager();
                    eventManager.triggerRandomEvent();
                }

                updateTurnIndicator();
            }
            
            function setupSkillButtons() {
                skillsXContainer.innerHTML = '';
                skillsOContainer.innerHTML = '';
                
                const createButton = (skill, playerClass) => {
                    const button = document.createElement('button');
                    button.className = 'skill-button';
                    button.innerHTML = skill.icon;
                    if (skill.type === 'active') {
                        button.id = `${skill.id}-${playerClass}`;
                        button.title = `${skill.name}: ${skill.description}`;
                        if (skill.implemented && playerClass === X_CLASS) {
                            button.addEventListener('click', () => {
                                if (isPaused) return;
                                const skillActions = { 'bomb': () => activateBomb(X_CLASS, 'bomb'), 'heal': () => activateHeal(X_CLASS, 'heal'), 'shield': () => activateShield(X_CLASS, 'shield'), 'sacrifice': () => activateSacrifice(X_CLASS, 'sacrifice'), 'mirror': () => activateMirror(X_CLASS, 'mirror'), 'swap': () => activateSwap(X_CLASS, 'swap'), 'shove': () => activateShove(X_CLASS, 'shove'), };
                                skillActions[skill.id]?.();
                            });
                        } else { button.disabled = true; }
                    } else { button.id = `${skill.id}-indicator-${playerClass}`; button.title = `${skill.name} (Passiva): ${skill.description}`; button.disabled = true; button.style.cursor = 'help'; }
                    return button;
                }

                Object.keys(skills.x).forEach(skillId => { if (skills.x[skillId] === true && ALL_SKILLS[skillId]) { skillsXContainer.appendChild(createButton(ALL_SKILLS[skillId], X_CLASS)); } });
                Object.keys(skills.o).forEach(skillId => { if (skills.o[skillId] === true && ALL_SKILLS[skillId]) { skillsOContainer.appendChild(createButton(ALL_SKILLS[skillId], O_CLASS)); } });
                
                updateSkillButtonsState();
            }
            
            function drainHealth() {
                if (!isGameActive || isPaused) return;
                if (isOTurn) { if (healthO > 0) healthO = Math.max(0, healthO - HEALTH_DRAIN_PER_SECOND); }
                else { if (healthX > 0) healthX = Math.max(0, healthX - HEALTH_DRAIN_PER_SECOND); }
                updateHealthBars();
                if (healthX <= 0 || healthO <= 0) endGame();
            }
            
            function clearInterdiction() {
                if (interdictedCellIndex !== -1) {
                    const interdictedCell = cellElements[interdictedCellIndex];
                    if (interdictedCell) interdictedCell.classList.remove('interdicted');
                    interdictedCellIndex = -1;
                    logAction("Interdi√ß√£o da c√©lula removida.", 'system-log');
                }
            }
            
            function showTurnAnnouncement() {
                if (!isGameActive) return;
                const currentPlayerName = isOTurn ? (gamePlayerLabelO.innerText) : (savedPlayerName || 'Jogador X');
                turnAnnouncementText.textContent = `Turno de ${currentPlayerName}`;
                turnAnnouncementContainer.classList.add('show');
                turnAnnouncementContainer.addEventListener('animationend', () => { turnAnnouncementContainer.classList.remove('show'); }, { once: true });
            }
            
            function applyDamageEffects(winnerClass, damage) {
                const defenderClass = winnerClass === X_CLASS ? O_CLASS : X_CLASS;
                const defenderChar = defenderClass === X_CLASS ? 'x' : 'o';
                showFloatingText(defenderChar, `-${Math.round(damage)}`, 'damage');

                if (winnerClass === X_CLASS) healthO = Math.max(0, healthO - damage);
                else healthX = Math.max(0, healthX - damage);
                updateHealthBars();
                if (healthX <= 0 || healthO <= 0) {
                    endGame();
                } else {
                    const healthBgToAnimate = winnerClass === X_CLASS ? healthBgO : healthBgX;
                    healthBgToAnimate.classList.add('damage');
                    setTimeout(() => healthBgToAnimate.classList.remove('damage'), 500);
                    playSound(attackSound);
                    setTimeout(() => {
                        playSound(hitSound);
                        triggerAnimation(winnerClass === X_CLASS ? charX : charO, winnerClass === X_CLASS ? charO : charX, winnerClass === X_CLASS);
                        if (isGameActive) {
                            swapTurns();
                        }
                    }, 300);
                }
            }
            
            function swapTurns() {
                turnCount++;
                if (gameMode.startsWith('caotico') && eventManager) {
                    let eventExpired = false;
                    if (eventManager.meteorShower.turnsLeft > 0) {
                        eventManager.meteorShower.turnsLeft--;
                        if (eventManager.meteorShower.turnsLeft === 0) {
                            logAction('Um meteoro ‚òÑÔ∏è atinge o campo de batalha!', 'system-log');
                            const allPieces = [...movesX, ...movesO];
                            if (allPieces.length > 0) {
                                const pieceToDestroy = allPieces[Math.floor(Math.random() * allPieces.length)];
                                const wasX = pieceToDestroy.classList.contains(X_CLASS);
                                logAction(`A pe√ßa na casa ${parseInt(pieceToDestroy.dataset.cellIndex) + 1} foi destru√≠da!`, 'system-log');
                                playSound(bombSound);
                                if (wasX) { movesX = movesX.filter(c => c !== pieceToDestroy); } 
                                else { movesO = movesO.filter(c => c !== pieceToDestroy); }
                                pieceToDestroy.classList.remove(X_CLASS, O_CLASS, 'oldest-piece', 'foggy');
                                updateOldestPieceIndicator();
                            } else { logAction('O meteoro errou, pois n√£o havia alvos.', 'system-log'); }
                            eventExpired = true;
                        }
                    }
                    if (!eventExpired && eventManager.minedCell.turnsLeft > 0) {
                        eventManager.minedCell.turnsLeft--;
                        if (eventManager.minedCell.turnsLeft === 0) { logAction('A Mina Terrestre üí• n√£o foi ativada e se dissipou.', 'system-log'); eventExpired = true; }
                    }
                    if (!eventExpired && eventManager.cursedCell.turnsLeft > 0) {
                        eventManager.cursedCell.turnsLeft--;
                        if (eventManager.cursedCell.turnsLeft === 0) { logAction('A C√©lula Amaldi√ßoada se dissipou.', 'system-log'); eventExpired = true; }
                    }
                    if (!eventExpired && eventManager.portals.turnsLeft > 0) {
                        eventManager.portals.turnsLeft--;
                        if (eventManager.portals.turnsLeft === 0) { logAction('Os portais üåÄ se fecharam.', 'system-log'); eventExpired = true; }
                    }
                    if (!eventExpired && eventManager.blackHole.turnsLeft > 0) {
                        eventManager.blackHole.turnsLeft--;
                        if (eventManager.blackHole.turnsLeft === 0) { logAction('O Buraco Negro ‚ö´ se dissipou.', 'system-log'); eventExpired = true; }
                    }
                    if (!eventExpired && eventManager.foggyCells.length > 0) {
                        if (eventManager.foggyCells.turnCreated === undefined) { eventManager.foggyCells.turnCreated = isOTurn; } 
                        else if (eventManager.foggyCells.turnCreated === isOTurn) { logAction('A N√©voa de Batalha üå´Ô∏è se dissipou!', 'system-log'); eventExpired = true; }
                    }
                    if (!eventExpired && eventManager.powerInversionActive) {
                        if (eventManager.powerInversionTurn === undefined) { eventManager.powerInversionTurn = isOTurn; } 
                        else if (eventManager.powerInversionTurn === isOTurn) { logAction('O efeito da Invers√£o de Poder ‚ö° acabou.', 'system-log'); eventExpired = true; }
                    }
                    if (eventExpired) {
                        eventManager.consumeAndRefresh();
                    }
                }
                isOTurn = !isOTurn;
                updateTurnIndicator();
                showTurnAnnouncement();
                if (isGameActive && isOTurn && (gameMode.includes('single') || gameMode === 'campaign')) {
                    triggerAiTurn();
                }
            }
            
            function triggerAnimation(attacker, defender, isXAttacking) {
                const attackDir = isXAttacking ? '30px' : '-30px';
                const hitDir = isXAttacking ? '-15px' : '15px';
                attacker.style.setProperty('--translate-x', attackDir);
                defender.style.setProperty('--translate-x', hitDir);
                attacker.classList.add('attack');
                defender.classList.add('hit');
                setTimeout(() => {
                    attacker.classList.remove('attack');
                    defender.classList.remove('hit');
                }, 600);
            }
            
            function handleDamage(winnerClass, damage = DAMAGE_PER_POINT, winningCombo = null) {
                if(winnerClass === O_CLASS) opponentPoints++;
                const defenderClass = winnerClass === X_CLASS ? O_CLASS : X_CLASS;
                let finalDamage = damage;
                logAction(`PONTO PARA ${winnerClass.toUpperCase()}!`, `player-${winnerClass}-log`);
                const isTaticOrChaotic = gameMode.startsWith('tatico') || gameMode.startsWith('caotico') || gameMode === 'campaign';
                if (isTaticOrChaotic && skills[defenderClass] && skills[defenderClass].shieldActive) {
                    logAction(`Escudo üõ°Ô∏è de ${defenderClass.toUpperCase()} bloqueia o ataque!`, `player-${defenderClass}-log`);
                    playSound(shieldSound);
                    skills[defenderClass].shieldActive = false;
                    const defenderChar = defenderClass === X_CLASS ? charX : charO;
                    defenderChar.classList.remove('shielded');
                    updateSkillButtonsState();
                    setTimeout(() => swapTurns(), 500);
                    return;
                }
                if (isTaticOrChaotic && skills[winnerClass]) {
                    if (skills[winnerClass].damageBoostActive) {
                        finalDamage *= 2;
                        logAction(`Sacrif√≠cio üíÄ dobra o dano para ${finalDamage}!`, `player-${winnerClass}-log`);
                        skills[winnerClass].damageBoostActive = false;
                        const winnerChar = winnerClass === X_CLASS ? charX : charO;
                        winnerChar.classList.remove('damage-boost');
                    }
                    if (skills[winnerClass].vampirism) {
                        const healAmount = Math.floor(finalDamage * 0.5);
                        const winnerChar = winnerClass === X_CLASS ? 'x' : 'o';
                        showFloatingText(winnerChar, `+${healAmount}`, 'heal');
                        if (winnerClass === X_CLASS) { healthX = Math.min(100, healthX + healAmount); } else { healthO = Math.min(100, healthO + healAmount); }
                        logAction(`Vampirismo ü©∏ cura ${healAmount} de vida para ${winnerClass.toUpperCase()}.`, `player-${winnerClass}-log`);
                        playSound(healSound);
                        updateHealthBars();
                    }
                }
                if (gameMode.startsWith('caotico') && eventManager && eventManager.powerInversionActive) {
                    const attackerHealth = winnerClass === X_CLASS ? healthX : healthO;
                    const defenderHealth = winnerClass === X_CLASS ? healthO : healthX;
                    if (attackerHealth < defenderHealth) {
                        finalDamage *= 1.5;
                        logAction(`Invers√£o de Poder ‚ö°! ${winnerClass.toUpperCase()} causa dano aumentado: ${finalDamage.toFixed(0)}!`, `player-${winnerClass}-log`);
                    }
                }
                if (winningCombo) {
                    boardElement.classList.add('locked', 'dimmed-board');
                    drawWinningLaserLine(winnerClass, winningCombo);
                    setTimeout(() => {
                        boardElement.classList.remove('dimmed-board', 'locked');
                        winningLaserLine.className = ''; winningLaserLine.classList.remove('show');
                        winningCombo.forEach(index => { cellElements[index].classList.remove('winning-cell-pulse'); cellElements[index].style.removeProperty('--pulse-color'); });
                        applyDamageEffects(winnerClass, finalDamage);
                    }, 1500);
                } else {
                    applyDamageEffects(winnerClass, finalDamage);
                }
            }
            
            function endGame() {
                isGameActive = false;
                pauseButton.classList.remove('visible'); // Esconde o bot√£o de pause no fim do jogo
                stopBattleMusic();
                clearInterval(drainInterval); clearTimeout(aiTimeout);
                if(eventManager) eventManager.stop();
                const playerWon = healthO <= 0 && healthX > 0;
                if (gameMode === 'campaign') {
                    const gameData = { playerWon, playerFinalHealth: healthX, opponentFinalHealth: healthO, turnCount, skillsUsed: playerSkillsUsed.x, opponentPoints, swappedOwnWithEnemy, playerUsedCenter: movesX.some(c => c.dataset.cellIndex === '4'), wonOnDiagonal };
                    handleCampaignEnd(gameData);
                    return;
                }
                playSound(victorySound);
                const winner = playerWon ? charX : charO;
                const loser = playerWon ? charO : charX;
                const winnerColor = playerWon ? 'var(--cor-x)' : 'var(--cor-o)';
                winner.style.setProperty('--winner-color', winnerColor);
                winner.classList.add('victory');
                loser.classList.add('defeat');
                const winnerName = playerWon ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText;
                winningMessageTextElement.innerText = `${winnerName} venceu!`;
                winningMessageElement.classList.add('show');
                boardElement.classList.add('locked');
            }
            
            function updateTurnIndicator() {
                healthContainerX.classList.toggle('active', !isOTurn);
                healthContainerO.classList.toggle('active', isOTurn);
                charX.classList.toggle('turn-active', !isOTurn);
                charO.classList.toggle('turn-active', isOTurn);
                if (!isOTurn) charX.style.setProperty('--player-color', 'var(--cor-x)');
                else charO.style.setProperty('--player-color', 'var(--cor-o)');
                if(gameMode.startsWith('tatico') || gameMode === 'campaign' || gameMode.startsWith('caotico')) updateSkillButtonsState();
            }
            
            function updateHealthBars() {
                let maxHealthX = 100;
                let maxHealthO = 100;
                if(gameMode === 'campaign' && currentLevelData?.customInitialHealth) {
                    maxHealthX = currentLevelData.customInitialHealth.x || 100;
                    maxHealthO = currentLevelData.customInitialHealth.o || 100;
                }
                healthBarX.style.width = `${(healthX / maxHealthX) * 100}%`;
                healthBarO.style.width = `${(healthO / maxHealthO) * 100}%`;
            }
            
            function checkWin(currentClass, currentMoves) {
                const playerMoves = currentMoves.map(el => parseInt(el.dataset.cellIndex));
                if (playerMoves.length < 3) return { hasWon: false, combo: null };
                for (const combo of WINNING_COMBINATIONS) {
                    if (combo.every(i => playerMoves.includes(i))) { return { hasWon: true, combo: combo }; }
                }
                return { hasWon: false, combo: null };
            }
            
            function placeMark(cell, currentClass) {
                const currentMoves = currentClass === X_CLASS ? movesX : movesO;
                const playerName = currentClass === X_CLASS ? gamePlayerLabelX.innerText : gamePlayerLabelO.innerText;
                logAction(`${playerName} marca a casa ${parseInt(cell.dataset.cellIndex) + 1}.`, `player-${currentClass}-log`);
                clearInterdiction();
                if (currentMoves.length >= MAX_MOVES) {
                    const oldestCell = currentMoves.shift();
                    oldestCell.classList.remove(X_CLASS, O_CLASS, 'oldest-piece');
                }
                cell.classList.add(currentClass);
                currentMoves.push(cell);
                if(currentClass === X_CLASS && cell.dataset.cellIndex === '4') { playerUsedCenter = true; }
                updateOldestPieceIndicator();
                const winResult = checkWin(currentClass, currentMoves);
                if (winResult.hasWon) {
                    if (currentClass === X_CLASS) {
                        const diagonalCombos = [[0,4,8], [2,4,6]];
                        wonOnDiagonal = diagonalCombos.some(c => c.every(i => winResult.combo.includes(i)));
                    }
                    handleDamage(currentClass, DAMAGE_PER_POINT, winResult.combo);
                } else if(isGameActive) {
                    swapTurns();
                }
            }
            
            function handleCaoticClick(e) {
                if (isPaused) return;
                const cell = e.target;
                if (gameMode.startsWith('caotico_single') && isOTurn) return;
                processCaoticMove(cell);
            }

            function processCaoticMove(cell) {
                if (!isGameActive || !cell || cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS) || cell.classList.contains('black-hole')) return;
                const currentClass = isOTurn ? O_CLASS : X_CLASS;
                let targetCell = cell;
                if (eventManager && eventManager.hasActiveEvent) {
                    if (eventManager.isMined(cell)) {
                        eventManager.triggerMine(currentClass);
                        if (isGameActive) swapTurns();
                        return;
                    }
                    if (eventManager.isCursed(cell)) {
                        logAction(`A C√©lula Amaldi√ßoada foi ativada! Ambos perdem 10 de vida.`, 'system-log');
                        showFloatingText('x', '-10', 'damage');
                        showFloatingText('o', '-10', 'damage');
                        healthX = Math.max(0, healthX - 10);
                        healthO = Math.max(0, healthO - 10);
                        updateHealthBars();
                        eventManager.consumeAndRefresh();
                        if (isGameActive) { if (healthX <= 0 || healthO <= 0) endGame(); else swapTurns(); }
                        return;
                    } 
                    if (cell.classList.contains('portal')) {
                        const otherPortal = eventManager.getOtherPortal(cell);
                        if (otherPortal && !otherPortal.classList.contains(X_CLASS) && !otherPortal.classList.contains(O_CLASS)) {
                            playSound(teleportSound);
                            logAction(`${currentClass.toUpperCase()} entrou num portal e saiu na casa ${parseInt(otherPortal.dataset.cellIndex) + 1}!`, `player-${currentClass}-log`);
                            targetCell = otherPortal;
                            eventManager.consumeAndRefresh();
                        }
                    }
                }
                placeMark(targetCell, currentClass);
            }
            
            function handleVsAiClick(e) {
                if (isPaused) return;
                if (isOTurn || !isGameActive) return;
                const cell = e.target;
                if (!isGameActive || cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS) || cell.classList.contains('interdicted')) return;
                placeMark(cell, X_CLASS);
            }
            
            function handleLocalClick(e) {
                if (isPaused) return;
                const cell = e.target;
                if (!isGameActive || cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS) || cell.classList.contains('interdicted')) return;
                const currentClass = isOTurn ? O_CLASS : X_CLASS;
                placeMark(cell, currentClass);
            }
            
            function handleTaticoClick(e) {
                if (isPaused) return;
                const cell = e.target;
                if (targetingState) {
                    if (targetingState.skill === 'bomb') { handleBombExecution(cell); }
                    else if (targetingState.skill === 'sacrifice') { handleSacrificeExecution(cell); }
                    else if (targetingState.skill === 'swap') {
                        if (targetingState.step === 1) { if(cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS)) { targetingState.firstCell = cell; targetingState.step = 2; cell.classList.add('swap-first-pick'); logAction("Primeira pe√ßa selecionada para troca. Selecione a segunda.", "system-log"); } }
                        else if (targetingState.step === 2) { if(cell !== targetingState.firstCell && (cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS))) { handleSwapExecution(targetingState.firstCell, cell); } }
                    } else if (targetingState.skill === 'shove') {
                        if (targetingState.step === 1) { if (cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS)) { targetingState.pieceToMove = cell; targetingState.step = 2; logAction("Pe√ßa selecionada. Agora escolha uma casa vazia adjacente para empurr√°-la.", "system-log"); updateShoveTargets(cell); } }
                        else if (targetingState.step === 2) {
                            if (cell.classList.contains('targetable')) { handleShoveExecution(targetingState.pieceToMove, cell); }
                            else if (cell !== targetingState.pieceToMove && (cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS))) { updateShoveTargets(cell, true); targetingState.pieceToMove = cell; logAction("Nova pe√ßa selecionada. Escolha uma casa vazia adjacente.", "system-log"); }
                        }
                    }
                    return;
                }
                const cellIndex = parseInt(cell.dataset.cellIndex);
                if (!isGameActive || cell.classList.contains(X_CLASS) || cell.classList.contains(O_CLASS) || cellIndex === interdictedCellIndex) return;
                const currentClass = isOTurn ? O_CLASS : X_CLASS;
                placeMark(cell, currentClass);
            }
            
            function wouldWin(currentClass, potentialCell, currentMoves) {
                const currentMoveIndices = currentMoves.map(el => parseInt(el.dataset.cellIndex));
                const potentialMoveIndices = [...currentMoveIndices, parseInt(potentialCell.dataset.cellIndex)];
                if (potentialMoveIndices.length > MAX_MOVES) { potentialMoveIndices.shift(); }
                return WINNING_COMBINATIONS.some(combo => combo.every(index => potentialMoveIndices.includes(index)));
            }
            
            // =======================================================================
            // ARQUITETURA DE INTELIG√äNCIA ARTIFICIAL (CORRIGIDA)
            // =======================================================================

            function triggerAiTurn() {
                if (isGameActive && isOTurn && (gameMode.includes('single') || gameMode === 'campaign')) {
                    if (isPaused) return;
                    boardElement.classList.add('locked');

                    let aiBrain;
                    
                    switch(gameMode) {
                        case 'tatico_single':
                            aiBrain = aiTaticoDispatch;
                            break;
                        case 'caotico_single':
                            aiBrain = aiCaoticoDispatch;
                            break;
                        case 'campaign':
                            aiDifficulty = currentLevelData.aiDifficulty || 'normal';
                            aiBrain = aiTaticoDispatch;
                            break;
                        case 'single':
                        default:
                            aiBrain = aiStandardDispatch;
                            break;
                    }
                    
                    aiTimeout = setTimeout(aiBrain, 750 + Math.random() * 500);
                }
            }


            function aiStandardDispatch() {
                if (aiDifficulty === 'hard')      aiMoveDificil();
                else if (aiDifficulty === 'normal') aiMoveNormal();
                else                                aiMoveFacil();
            }

            function aiTaticoDispatch() {
                if (aiDifficulty === 'hard')      aiBrainTaticoDificil();
                else if (aiDifficulty === 'normal') aiBrainTaticoNormal();
                else                                aiBrainTaticoFacil();
            }

            function aiCaoticoDispatch() {
                if (aiDifficulty === 'hard')      aiBrainCaoticoDificil();
                else if (aiDifficulty === 'normal') aiBrainCaoticoNormal();
                else                                aiBrainCaoticoFacil();
            }


            function aiMoveFacil() {
                const availableCells = cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && c.dataset.cellIndex != interdictedCellIndex);
                const winningMove = availableCells.find(cell => wouldWin(O_CLASS, cell, movesO));

                if (winningMove) {
                    placeMark(winningMove, O_CLASS);
                } else if (availableCells.length > 0) {
                    const randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
                    placeMark(randomCell, O_CLASS);
                } else {
                    swapTurns();
                }
                boardElement.classList.remove('locked');
            }

            function aiMoveNormal() {
                const availableCells = cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && c.dataset.cellIndex != interdictedCellIndex);
                const winningMove = availableCells.find(cell => wouldWin(O_CLASS, cell, movesO));
                const blockingMove = availableCells.find(cell => wouldWin(X_CLASS, cell, movesX));
                
                if (winningMove) {
                    placeMark(winningMove, O_CLASS);
                } else if (blockingMove) {
                    placeMark(blockingMove, O_CLASS);
                } else if (availableCells.length > 0) {
                    const center = availableCells.find(c => c.dataset.cellIndex === '4');
                    if (center) {
                        placeMark(center, O_CLASS);
                    } else {
                        const randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
                        placeMark(randomCell, O_CLASS);
                    }
                } else {
                    swapTurns();
                }
                boardElement.classList.remove('locked');
            }

            function aiMoveDificil() {
                const availableCells = cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && c.dataset.cellIndex != interdictedCellIndex);
                const winningMove = availableCells.find(cell => wouldWin(O_CLASS, cell, movesO));
                const blockingMove = availableCells.find(cell => wouldWin(X_CLASS, cell, movesX));

                if (winningMove) {
                    placeMark(winningMove, O_CLASS);
                } else if (blockingMove) {
                    placeMark(blockingMove, O_CLASS);
                } else if (availableCells.length > 0) {
                    const center = availableCells.find(c => c.dataset.cellIndex === '4');
                    const corners = [0, 2, 6, 8].map(i => cellElements[i]).filter(c => availableCells.includes(c));
                    if (center) {
                        placeMark(center, O_CLASS);
                    } else if (corners.length > 0) {
                        placeMark(corners[Math.floor(Math.random() * corners.length)], O_CLASS);
                    } else {
                        placeMark(availableCells[Math.floor(Math.random() * availableCells.length)], O_CLASS);
                    }
                } else {
                    swapTurns();
                }
                boardElement.classList.remove('locked');
            }

            function aiBrainTaticoFacil() {
                aiMoveFacil();
            }

            function aiBrainTaticoNormal() {
                if (skills.o.heal && healthO < 35 && !playerSkillsUsed.o.includes('heal')) {
                    activateHeal(O_CLASS, 'heal');
                    boardElement.classList.remove('locked');
                    return;
                }
                const playerWillWin = cellElements.some(cell => 
                    !cell.classList.contains(X_CLASS) && 
                    !cell.classList.contains(O_CLASS) && 
                    wouldWin(X_CLASS, cell, movesX)
                );
                if (skills.o.shield && playerWillWin && !playerSkillsUsed.o.includes('shield')) {
                    activateShield(O_CLASS, 'shield');
                    boardElement.classList.remove('locked');
                    return;
                }

                aiMoveNormal();
            }

            function aiBrainTaticoDificil() {
                const availableCells = cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && c.dataset.cellIndex != interdictedCellIndex);
                
                const winningMove = availableCells.find(cell => wouldWin(O_CLASS, cell, movesO));
                if (winningMove) {
                    aiMoveDificil();
                    return;
                }

                if (skills.o.sacrifice && !playerSkillsUsed.o.includes('sacrifice') && movesO.length > 0) {
                    const tempMoves = [...movesO];
                    tempMoves.shift();
                    if (availableCells.some(cell => wouldWin(O_CLASS, cell, tempMoves))) {
                        handleSacrificeExecution(movesO[0]);
                         boardElement.classList.remove('locked');
                        return;
                    }
                }
                
                const blockingMove = availableCells.find(cell => wouldWin(X_CLASS, cell, movesX));
                if (blockingMove) {
                       if (skills.o.shield && healthO > 40 && !playerSkillsUsed.o.includes('shield')) {
                           activateShield(O_CLASS, 'shield');
                           boardElement.classList.remove('locked');
                           return;
                       }
                    aiMoveDificil();
                    return;
                }
                
                if (skills.o.heal && healthO < 50 && !playerSkillsUsed.o.includes('heal')) {
                       activateHeal(O_CLASS, 'heal');
                       boardElement.classList.remove('locked');
                       return;
                }

                aiMoveDificil();
            }

            function aiBrainCaoticoFacil() {
                const safeCells = cellElements.filter(c => {
                    return !c.classList.contains(X_CLASS) &&
                           !c.classList.contains(O_CLASS) &&
                           !c.classList.contains('black-hole') &&
                           c.dataset.cellIndex != interdictedCellIndex &&
                           !eventManager.isMined(c) &&
                           !eventManager.isCursed(c);
                });

                const cellsToConsider = safeCells.length > 0 ? safeCells : cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && !c.classList.contains('black-hole'));
                
                const winningMove = cellsToConsider.find(cell => wouldWin(O_CLASS, cell, movesO));

                if (winningMove) {
                    processCaoticMove(winningMove);
                } else if (cellsToConsider.length > 0) {
                    const randomCell = cellsToConsider[Math.floor(Math.random() * cellsToConsider.length)];
                    processCaoticMove(randomCell);
                } else {
                    swapTurns();
                }
                boardElement.classList.remove('locked');
            }

            function aiBrainCaoticoNormal() {
                const safeCells = cellElements.filter(c => {
                    return !c.classList.contains(X_CLASS) && 
                           !c.classList.contains(O_CLASS) &&
                           !c.classList.contains('black-hole') &&
                           c.dataset.cellIndex != interdictedCellIndex &&
                           !eventManager.isMined(c) && 
                           !eventManager.isCursed(c);
                });

                const cellsToConsider = safeCells.length > 0 ? safeCells : cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && !c.classList.contains('black-hole'));
                
                const winningMove = cellsToConsider.find(cell => wouldWin(O_CLASS, cell, movesO));
                const blockingMove = cellsToConsider.find(cell => wouldWin(X_CLASS, cell, movesX));
                if (winningMove) processCaoticMove(winningMove);
                else if (blockingMove) processCaoticMove(blockingMove);
                else {
                    if (cellsToConsider.length > 0) {
                        const center = cellsToConsider.find(c => c.dataset.cellIndex === '4');
                        if (center) processCaoticMove(center);
                        else processCaoticMove(cellsToConsider[Math.floor(Math.random() * cellsToConsider.length)]);
                    } else {
                        swapTurns();
                    }
                }
                boardElement.classList.remove('locked');
            }

            function aiBrainCaoticoDificil() {
                const safeCells = cellElements.filter(c => {
                    return !c.classList.contains(X_CLASS) &&
                           !c.classList.contains(O_CLASS) &&
                           !c.classList.contains('black-hole') &&
                           c.dataset.cellIndex != interdictedCellIndex &&
                           !eventManager.isMined(c) &&
                           !eventManager.isCursed(c);
                });
                const cellsToConsider = safeCells.length > 0 ? safeCells : cellElements.filter(c => !c.classList.contains(X_CLASS) && !c.classList.contains(O_CLASS) && !c.classList.contains('black-hole'));

                if (eventManager && eventManager.portals.cells.length > 0) {
                    for (const portal of eventManager.portals.cells) {
                        const otherPortal = eventManager.getOtherPortal(portal);
                        if (cellsToConsider.includes(portal) && wouldWin(O_CLASS, otherPortal, movesO)) {
                            logAction("A IA usa um portal para uma jogada de mestre!", 'player-o-log');
                            processCaoticMove(portal);
                            boardElement.classList.remove('locked');
                            return;
                        }
                    }
                }

                const winningMove = cellsToConsider.find(cell => wouldWin(O_CLASS, cell, movesO));
                const blockingMove = cellsToConsider.find(cell => wouldWin(X_CLASS, cell, movesX));
                const center = cellsToConsider.find(c => c.dataset.cellIndex === '4');
                const corners = [0, 2, 6, 8].map(i => cellElements[i]).filter(c => cellsToConsider.includes(c));

                if (winningMove) {
                    processCaoticMove(winningMove);
                } else if (blockingMove) {
                    processCaoticMove(blockingMove);
                } else if (center) {
                    processCaoticMove(center);
                } else if (corners.length > 0) {
                    processCaoticMove(corners[Math.floor(Math.random() * corners.length)]);
                } else if (cellsToConsider.length > 0) {
                    processCaoticMove(cellsToConsider[Math.floor(Math.random() * cellsToConsider.length)]);
                } else {
                    swapTurns();
                }
                boardElement.classList.remove('locked');
            }


            // =======================================================================
            // FIM DA SE√á√ÉO DE IA
            // =======================================================================
            
            function activateHeal(player, skillId) {
                if (isPaused) return;
                if (playerSkillsUsed[player]?.includes(skillId)) return;
                showFloatingText(player, `+${HEAL_AMOUNT}`, 'heal');
                playSound(healSound);
                if (player === X_CLASS) {
                    healthX = Math.min(100, healthX + HEAL_AMOUNT);
                } else {
                    healthO = Math.min(100, healthO + HEAL_AMOUNT);
                }
                playerSkillsUsed[player].push(skillId);
                logAction(`${player.toUpperCase()} usou Cura ‚ù§Ô∏è‚Äçü©π e recuperou ${HEAL_AMOUNT} de vida.`, `player-${player}-log`);
                updateHealthBars();
                updateSkillButtonsState();
                swapTurns();
            }

            function activateBomb(player, skillId) {
                if (isPaused) return;
                if (playerSkillsUsed[player]?.includes(skillId)) return;
                const enemyClass = player === X_CLASS ? O_CLASS : X_CLASS;
                const enemyPieces = cellElements.filter(c => c.classList.contains(enemyClass));
                if (enemyPieces.length === 0) {
                    showNotification("N√£o h√° pe√ßas inimigas no tabuleiro para bombardear!");
                    return;
                }
                logAction(`${player.toUpperCase()} prepara uma Bomba üí£. Selecione uma pe√ßa inimiga.`, `player-${player}-log`);
                targetingState = { skill: 'bomb', player };
                boardElement.classList.add('targeting');
                enemyPieces.forEach(cell => cell.classList.add('targetable'));
            }

            function handleBombExecution(cell) {
                if (!targetingState || targetingState.skill !== 'bomb' || !cell.classList.contains('targetable')) return;
                
                const player = targetingState.player;
                const enemyClass = player === X_CLASS ? O_CLASS : X_CLASS;
                
                if (cell.classList.contains(enemyClass)) {
                    const cellIndex = parseInt(cell.dataset.cellIndex);
                    playSound(bombSound);
                    
                    cell.classList.remove(enemyClass, 'oldest-piece');
                    if (enemyClass === X_CLASS) movesX = movesX.filter(c => c !== cell);
                    else movesO = movesO.filter(c => c !== cell);
                    
                    interdictedCellIndex = cellIndex;
                    cell.classList.add('interdicted');
                    
                    logAction(`Pe√ßa em ${cellIndex + 1} destru√≠da! A c√©lula ficar√° interditada por 1 turno.`, `player-${player}-log`);
                    
                    playerSkillsUsed[player].push('bomb');
                    resetTargetingMode();
                    updateOldestPieceIndicator();
                    swapTurns();
                }
            }

            function activateShield(player, skillId) {
                if (isPaused) return;
                if (playerSkillsUsed[player]?.includes(skillId) || (skills[player] && skills[player].shieldActive)) return;
                
                playSound(shieldSound);
                skills[player].shieldActive = true;
                const playerChar = player === X_CLASS ? charX : charO;
                playerChar.classList.add('shielded');
                
                playerSkillsUsed[player].push(skillId);
                logAction(`${player.toUpperCase()} ativou o Escudo üõ°Ô∏è.`, `player-${player}-log`);
                
                updateSkillButtonsState();
                swapTurns();
            }

            function activateSacrifice(player, skillId) {
                if (isPaused) return;
                if (playerSkillsUsed[player]?.includes(skillId)) return;
                const ownPieces = cellElements.filter(c => c.classList.contains(player));
                if (ownPieces.length === 0) {
                    showNotification("Voc√™ n√£o tem pe√ßas para sacrificar!");
                    return;
                }
                logAction(`${player.toUpperCase()} prepara um Sacrif√≠cio üíÄ. Escolha uma pe√ßa sua para destruir.`, `player-${player}-log`);
                targetingState = { skill: 'sacrifice', player };
                boardElement.classList.add('targeting', 'targeting-sacrifice', `is-${player}-turn`);
            }

            function handleSacrificeExecution(cell) {
                if (!targetingState || targetingState.skill !== 'sacrifice') return;
                const player = targetingState.player;
                if (cell.classList.contains(player)) {
                    const cellIndex = parseInt(cell.dataset.cellIndex);
                    cell.classList.remove(player, 'oldest-piece');
                    if (player === X_CLASS) movesX = movesX.filter(c => c !== cell);
                    else movesO = movesO.filter(c => c !== cell);
                    
                    skills[player].damageBoostActive = true;
                    const playerChar = player === X_CLASS ? charX : charO;
                    playerChar.classList.add('damage-boost');
                    
                    logAction(`Pe√ßa em ${cellIndex + 1} sacrificada! Pr√≥ximo dano dobrado.`, `player-${player}-log`);
                    playerSkillsUsed[player].push('sacrifice');
                    
                    resetTargetingMode();
                    updateOldestPieceIndicator();
                    swapTurns();
                }
            }
            
            function activateSwap(player, skillId) {
                if (isPaused) return;
                if (playerSkillsUsed[player]?.includes(skillId)) return;
                const allPieces = cellElements.filter(c => c.classList.contains(X_CLASS) || c.classList.contains(O_CLASS));
                if (allPieces.length < 2) {
                    showNotification("Precisa haver pelo menos 2 pe√ßas no tabuleiro para trocar.");
                    return;
                }
                logAction(`${player.toUpperCase()} prepara a Troca üîÅ. Selecione as duas pe√ßas.`, `player-${player}-log`);
                targetingState = { skill: 'swap', player, step: 1, firstCell: null };
                boardElement.classList.add('targeting', 'targeting-swap');
            }

            function handleSwapExecution(cell1, cell2) {
                if (!targetingState || targetingState.skill !== 'swap') return;

                const class1 = cell1.classList.contains(X_CLASS) ? X_CLASS : O_CLASS;
                const class2 = cell2.classList.contains(X_CLASS) ? X_CLASS : O_CLASS;

                cell1.classList.remove(class1);
                cell2.classList.remove(class2);
                cell1.classList.add(class2);
                cell2.classList.add(class1);

                const updateMoves = (moves, oldCell, newCell) => {
                    const index = moves.indexOf(oldCell);
                    if (index > -1) {
                        moves[index] = newCell;
                    }
                };

                if (class1 === X_CLASS) updateMoves(movesX, cell1, cell2); else updateMoves(movesO, cell1, cell2);
                if (class2 === X_CLASS) updateMoves(movesX, cell2, cell1); else updateMoves(movesO, cell2, cell1);

                logAction(`Pe√ßas trocadas!`, `player-${targetingState.player}-log`);
                playerSkillsUsed[targetingState.player].push('swap');
                
                resetTargetingMode();
                updateOldestPieceIndicator();

                const winX = checkWin(X_CLASS, movesX);
                const winO = checkWin(O_CLASS, movesO);
                if (winX.hasWon) handleDamage(X_CLASS, DAMAGE_PER_POINT, winX.combo);
                if (winO.hasWon) handleDamage(O_CLASS, DAMAGE_PER_POINT, winO.combo);
                
                swapTurns();
            }

            function activateShove(player, skillId) { /* ...Sua l√≥gica aqui... */ }
            function updateShoveTargets(originCell, clearOldOrigin = false) { /* ...Sua l√≥gica aqui... */ }
            function handleShoveExecution(originCell, destinationCell) { /* ...Sua l√≥gica aqui... */ }
            function activateMirror(player, skillId) { /* ...Sua l√≥gica aqui... */ }
            function handleMirrorReflection(player, skillId) { /* ...Sua l√≥gica aqui... */ }
            
            function resetTargetingMode() {
                if (!targetingState) return;
                boardElement.classList.remove('targeting', 'targeting-bomb', 'targeting-sacrifice', 'targeting-swap', 'targeting-shove', 'is-x-turn', 'is-o-turn');
                cellElements.forEach(cell => {
                    cell.classList.remove('targetable', 'swap-first-pick', 'shove-origin');
                });
                targetingState = null;
                updateSkillButtonsState();
            }
            
            function drawWinningLaserLine(winnerClass, combo) {
                const comboStr = [...combo].sort().join('');
                const lineClasses = {
                    '012': 'line-row-0', '345': 'line-row-1', '678': 'line-row-2',
                    '036': 'line-col-0', '147': 'line-col-1', '258': 'line-col-2',
                    '048': 'line-diag-0', '246': 'line-diag-1'
                };
                const lineClass = lineClasses[comboStr];

                if (lineClass) {
                    const pulseColor = winnerClass === X_CLASS ? 'var(--cor-x)' : 'var(--cor-o)';
                    winningLaserLine.style.setProperty('--laser-color', pulseColor);

                    winningLaserLine.className = 'winning-laser-active';
                    winningLaserLine.classList.add('show', lineClass);

                    combo.forEach(index => {
                        cellElements[index].style.setProperty('--pulse-color', pulseColor);
                        cellElements[index].classList.add('winning-cell-pulse');
                    });
                }
            }
            
            function updateSkillButtonsState() {
                const isVsAi = gameMode.includes('single') || gameMode === 'campaign';
                document.querySelectorAll('.skill-button').forEach(button => {
                    const skillId = button.id.split('-')[0];
                    const playerClass = button.id.includes('-x') ? 'x' : 'o';
                    
                    let isDisabled = (playerClass === 'x' && isOTurn) || (playerClass === 'o' && !isOTurn) || (targetingState !== null);
                    
                    if (isVsAi && playerClass === 'o') {
                        isDisabled = true;
                    }
                    
                    if (playerSkillsUsed[playerClass] && playerSkillsUsed[playerClass].includes(skillId)) {
                        isDisabled = true;
                    }
                    
                    if (!ALL_SKILLS[skillId] || ALL_SKILLS[skillId].type === 'passive') {
                        button.disabled = true;
                    } else {
                        button.disabled = isDisabled;
                    }
                });
            }

            function updateOldestPieceIndicator() {
                cellElements.forEach(cell => cell.classList.remove('oldest-piece'));
                if (movesX.length >= MAX_MOVES) {
                    movesX[0].classList.add('oldest-piece');
                }
                if (movesO.length >= MAX_MOVES) {
                    movesO[0].classList.add('oldest-piece');
                }
            }
            
            function applyAvatar(element, avatar) {
                if (avatar.type === 'image') {
                    element.style.backgroundImage = `url('${avatar.value}')`;
                    element.textContent = '';
                } else {
                    element.style.backgroundImage = 'none';
                    element.textContent = avatar.value;
                }
            }

            function openCharacterModal(player) {
                playerToEdit = player;
                presetCharsContainer.innerHTML = '';
                PRESET_EMOJIS.forEach(emoji => {
                    const charDiv = document.createElement('div');
                    charDiv.className = 'preset-char';
                    charDiv.textContent = emoji;
                    charDiv.onclick = () => selectPresetChar(emoji);
                    presetCharsContainer.appendChild(charDiv);
                });
                modal.classList.add('show');
            }
            
             function selectPresetChar(emoji) {
                const newAvatar = { type: 'emoji', value: emoji };
                if (playerToEdit === 'x_arsenal') {
                    playerXAvatar = newAvatar;
                    applyAvatar(arsenalCharPreview, playerXAvatar);
                } else if (playerToEdit === 'o') {
                    playerOAvatar = newAvatar;
                    applyAvatar(charPreviewO, playerOAvatar);
                }
                modal.classList.remove('show');
            }
            
            // --- FUN√á√ïES DE PAUSE ---
            function pauseGame() {
                if (!isGameActive || isPaused) return;
                isPaused = true;
                
                clearInterval(drainInterval);
                clearTimeout(aiTimeout);
                
                boardElement.classList.add('locked');
                pauseModal.classList.add('show');
                logAction('Jogo pausado.', 'system-log');
            }

            function resumeGame() {
                if (!isGameActive || !isPaused) return;
                isPaused = false;
                
                drainInterval = setInterval(drainHealth, 1000);
                
                if (!targetingState) {
                    boardElement.classList.remove('locked');
                }
                pauseModal.classList.remove('show');
                logAction('Jogo retomado.', 'system-log');
                
                if (isOTurn && (gameMode.includes('single') || gameMode === 'campaign')) {
                    triggerAiTurn();
                }
            }

            function quitMatch() {
                isGameActive = false;
                isPaused = false;
                clearInterval(drainInterval);
                clearTimeout(aiTimeout);
                
                stopBattleMusic();
                pauseModal.classList.remove('show');

                showScreen(modeSelectMenu, 'back');
            }


            // --- GLOBAL EVENT LISTENERS ---
            notificationCloseButton.addEventListener('click', () => notificationModal.classList.remove('show'));
            saveArsenalButton.addEventListener('click', saveArsenalAndProceed);
            arsenalPlayerNameInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') saveArsenalAndProceed(); });
            arsenalCharPreview.addEventListener('click', () => openCharacterModal('x_arsenal'));
            charPreviewO.addEventListener('click', () => openCharacterModal('o'));
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('show'); });
            changeArsenalButton.addEventListener('click', () => { 
                populateArsenalScreen();
                showScreen(arsenalScreen, 'back'); 
            });
            campaignButton.addEventListener('click', showCampaignMap);
            backToMenuFromCampaignButton.addEventListener('click', () => showScreen(modeSelectMenu, 'back'));
            singlePlayerButton.addEventListener('click', () => { gameMode = 'single'; showScreen(difficultySelectMenu, 'forward'); });
            localMultiplayerButton.addEventListener('click', () => { gameMode = 'local'; showScreen(playerSetupMenu, 'forward'); });
            taticoModeButton.addEventListener('click', () => { showScreen(taticoSubmenu, 'forward'); });
            taticoSubmenuButtons.forEach(button => { button.addEventListener('click', () => { selectedSubMode = button.dataset.submode; opponentSelectTitle.innerText = `Modo ${selectedSubMode === 'tatico' ? 'Batalha T√°tica' : 'Arena Ca√≥tica'}`; showScreen(opponentSelectMenu, 'forward'); }); });
            opponentHumanButton.addEventListener('click', () => { gameMode = selectedSubMode; showScreen(playerSetupMenu, 'forward'); });
            opponentAiButton.addEventListener('click', () => { gameMode = selectedSubMode + '_single'; showScreen(difficultySelectMenu, 'forward'); });
            difficultyButtons.forEach(button => { button.addEventListener('click', () => { aiDifficulty = button.dataset.difficulty; initializeMatch(); showScreen(gameScreen, 'forward'); }); });
            backToModeSelectBtn.addEventListener('click', () => showScreen(modeSelectMenu, 'back'));
            backToModeSelectBtn2.addEventListener('click', () => { const targetScreen = (gameMode === 'single') ? modeSelectMenu : opponentSelectMenu; showScreen(targetScreen, 'back'); });
            backToModeSelectBtn3.addEventListener('click', () => showScreen(modeSelectMenu, 'back'));
            backToTaticoMenuBtn.addEventListener('click', () => showScreen(taticoSubmenu, 'back'));
            startGameButton.addEventListener('click', () => { initializeMatch(); showScreen(gameScreen, 'forward'); });
            historyToggleButton.addEventListener('click', () => historyPanel.classList.toggle('show'));
            restartButton.addEventListener('click', () => { if (gameMode === 'campaign') { showCampaignMap(); } else { showScreen(modeSelectMenu, 'back'); } });
            closeLevelModalButton.addEventListener('click', () => { levelDetailModal.classList.remove('show'); });
            levelDetailModal.addEventListener('click', (e) => { if (e.target === levelDetailModal) { levelDetailModal.classList.remove('show'); } });
            tutorialButton.addEventListener('click', () => showScreen(tutorialScreen, 'forward'));
            backToMenuFromTutorialButton.addEventListener('click', () => showScreen(modeSelectMenu, 'back'));
            
            // LISTENERS DE PAUSE ADICIONADOS
            pauseButton.addEventListener('click', pauseGame);
            resumeButton.addEventListener('click', resumeGame);
            quitMatchButton.addEventListener('click', quitMatch);

            // FUN√á√ÉO RESTAURADA
            function setupTutorial() {
                tutorialSkillsList.innerHTML = '';
                for (const skillId in ALL_SKILLS) {
                    const skill = ALL_SKILLS[skillId];
                    const skillElement = document.createElement('div');
                    skillElement.className = 'skill-entry';
                    skillElement.innerHTML = `<span class="skill-icon">${skill.icon}</span><div><strong>${skill.name} (${skill.type==='active'?'Ativa':'Passiva'}):</strong><span>${skill.description}</span></div>`;
                    tutorialSkillsList.appendChild(skillElement);
                }
                const accordionHeaders = document.querySelectorAll('.accordion-header');
                accordionHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        header.classList.toggle('active');
                        const panel = header.nextElementSibling;
                        panel.classList.toggle('show');
                        if (panel.style.maxHeight) { panel.style.maxHeight = null; } 
                        else { panel.style.maxHeight = panel.scrollHeight + "px"; } 
                    });
                });
            }

            // --- GAME INITIALIZATION ---
            document.addEventListener('DOMContentLoaded', () => {
                loadData();
                setupTutorial();
            });
        </script>
        </body>
</html>
